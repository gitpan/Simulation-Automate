diff -r -b -B --ignore-all-space -u Simulation-Automate-0.9.7/Automate/Analysis.pm Simulation-Automate-1.0.0/Automate/Analysis.pm
--- Simulation-Automate-0.9.7/Automate/Analysis.pm	2003-09-04 11:04:52.000000000 +0000
+++ Simulation-Automate-1.0.0/Automate/Analysis.pm	2004-01-05 11:11:56.000000000 +0000
@@ -1,7 +1,7 @@
 package Simulation::Automate::Analysis;
 
 use vars qw( $VERSION );
-$VERSION = "0.9.6";
+$VERSION = "1.0.0";
 
 #################################################################################
 #                                                                              	#
@@ -84,7 +85,8 @@
 /^\s+$/ && next;
 /^\s*\#/ && next;
 chomp;
-
+s/\s+$//;
+s/^\s+//;
 my @row=split(/[\s\t]+/,$_);
 my $ri=0;
 
@@ -122,7 +122,7 @@
 if(${$trend{$logkey}}[$i]>0){
 ${$trend{$logkey}}[$i]=log(${$trend{$logkey}}[$i])/log(10); 
 } else {
-${$trend{$logkey}}[$i]=''
+${$trend{$logkey}}[$i]='';
 }
 } # each $i
 } # each $logkey
@@ -140,7 +140,9 @@
 my $stdev=0;
 my $pct_bad=shift||0; # means we throw 50% of the devices away as outliers to calculate the rough mean
 my $delta=shift||2e10; # means we take all devices within 20% deviation from actual mean 
-my @tmp_values=sort numerical @$value_array_ref;
+
+my @tmp_values=sort numerical @{$value_array_ref};
+
 my $min=$tmp_values[0];
 my $max=$tmp_values[@tmp_values-1];
 #print "#all values:".scalar(@tmp_values)."\n";
@@ -213,14 +215,14 @@
 # number of bins, number of sigmas for with ofinterval
 my $nbins=shift; 
 my $nsigma=shift;
-my $min=shift||'NOT DEFINED';
-my $max=shift||'NOT DEFINED';
+my $min=shift||'CALC';
+my $max=shift||'CALC';
 
 # calculate mean & sigma and min/max/binwidth
 my ($avg,$stdev)=@{&calc_average($value_array_ref)};
 if(not $nsigma){$nsigma=6}
 #if((not $min) && ($min!=0)){
-if($min=~/N/) { 
+if($min=~/C/) { 
 $min=$avg-$nsigma*$stdev;
 if($stdev>$avg) {
 # in this case take min and max value of set
@@ -228,11 +230,10 @@
   foreach my $val (@{$value_array_ref}) {
     if($val<$min){$min=$val}
   }
-if($v){print "# MIN:$min\n";}
 }
 }
-
-if( $max=~/N/) { 
+if($v){print "# MIN:$min\n";}
+if( $max=~/C/) { 
 $max=$avg+$nsigma*$stdev;
 
 if(1||$stdev>$avg) {
@@ -348,7 +350,7 @@
 
 my $par=$pars[0];
 
-if($v){print "# Processing $par\n";}
+print "# Processing $par\n" if $v;
 
 my @tmpa=@{&build_histogram(\@{$trend{$par}},$nbins,3,$min,$max)};
 my $tmp=$tmpa[0];
diff -r -b -B --ignore-all-space -u Simulation-Automate-0.9.7/Automate/Dictionary.pm Simulation-Automate-1.0.0/Automate/Dictionary.pm
--- Simulation-Automate-0.9.7/Automate/Dictionary.pm	2003-09-04 11:04:52.000000000 +0000
+++ Simulation-Automate-1.0.0/Automate/Dictionary.pm	2004-01-05 11:11:56.000000000 +0000
@@ -1,7 +1,7 @@
 package Simulation::Automate::Dictionary;
 
 use vars qw( $VERSION );
-$VERSION = "0.9.6";
+$VERSION = "1.0.0";
 
 #################################################################################
 #                                                                              	#
Only in Simulation-Automate-1.0.0/Automate: PostProcessorsOld.pm
diff -r -b -B --ignore-all-space -u Simulation-Automate-0.9.7/Automate/PostProcessors.pm Simulation-Automate-1.0.0/Automate/PostProcessors.pm
--- Simulation-Automate-0.9.7/Automate/PostProcessors.pm	2003-09-04 11:04:52.000000000 +0000
+++ Simulation-Automate-1.0.0/Automate/PostProcessors.pm	2004-01-05 11:11:56.000000000 +0000
@@ -1,11 +1,11 @@
 package Simulation::Automate::PostProcessors;
 
 use vars qw( $VERSION );
-$VERSION = "0.9.6";
+$VERSION = "1.0.0";
 
 ################################################################################
 #                                                                              #
-#  Copyright (C) 2000,2002 Wim Vanderbauwhede. All rights reserved.            #
+#  Copyright (C) 2000,2002-2003 Wim Vanderbauwhede. All rights reserved.       #
 #  This program is free software; you can redistribute it and/or modify it     #
 #  under the same terms as Perl itself.                                        #
 #                                                                              #
@@ -20,9 +20,9 @@
 $Id: PostProcessors.pm,v 1.2 2003/09/04 09:54:19 wim Exp $
 
 =cut
+#use warnings;
+#use strict;
 
-use strict;
-use Cwd;
 use Carp;
 use lib '.','..';
 
@@ -35,203 +36,104 @@
 # Histogram: to create simple histograms
 
 #------------------------------------------------------------------------------
-# This is a very generic module to generate plots from any sweep 
-
-sub SweepVar {
-my @args=@_;
-my $extra_args_ref=&prepare_plot(@args);
-my @extra_args=@{$extra_args_ref};
-#@extra_args may only contain a subref 
-my $subref=(@extra_args==1)?$extra_args[0]:0;
-
-(!@{$simdata{$normvar}})&&(${$simdata{$normvar}}[0]=1);
-#Use the current value of $normvar. I think this is wrong, count is not the current value if there is more than one loop
-#my $norm=(@{$simdata{$normvar}}>1)?${$simdata{$normvar}}[$count]:${$simdata{$normvar}}[0];
-#The right way is:
-my $norm=(@{$simdata{$normvar}}>1)?$current_set_vals{$normvar}:${$simdata{$normvar}}[0];
-#my $norm=${$@extra_argssimdata{$normvar}}[$count]||1; 
-
-my $col=$datacol+1;
-
+# This is a very generic module to generate XY plots from any sweep 
+sub XYPlot {
+#determine whether the results are single points or a range
+  if($xvar && @{$simdata{$xvar}}>1) { # point by point
 my @sweepvarvals=@{$simdata{$sweepvar}};
 
-#hook for preprocessing routine
-if($subref) {
-&{$subref}("${simtempl}_C$count.res");
-#NEW02072003#&{$subref}($results_file);
-}
-
-#this is to combine the values for different buffers into 1 file
-
+  # This is to combine the values for different buffers into 1 file
 if($verylast==0) {
-# create the header (basically, only comments)
-#open(HEAD,">$results_file");
-my $resheader='';
-open(IN,"<${simtempl}_C$count.res");
-#NEW02072003#open(IN,"<$results_file");
-
-while(<IN>) {
-/\#/ && !/Parameters|$sweepvar/ && do {
-#print HEAD $_
-$resheader.=$_;
-};
-}
-close IN;
-open(HEAD,">$results_file");
-print HEAD $resheader;
-close HEAD;
-# now add the simulation results. The difference with ${simtempl}_C$count.res
+    open(RES,">$results_file_name");
+    print RES $resheader;
+    # Now add the simulation results. The difference with the raw data
 # is that the value of $sweepvar is added as the first column.
 my $i=0;
 foreach my $sweepvarval ( @sweepvarvals ) {
-open(RES,">>${simtempl}-${anatempl}-${current_set_valstr}.res");
 print RES "$sweepvarval\t$results[$i]";
-close RES;
 $i++;
 }
+    close RES;
+  } else {
+    # On the very last run, collect the results into one nice plot
+    # X values are in the first col, so add 1 to YCOL
+    $ycol++;
 
-#hook for preprocessing routine
-if($subref) {
-&{$subref}($results_file);
-}
-if($last) {
-
-if($interactive) {
-
-foreach my $sweepvarval ( @sweepvarvals ) {
-#create the header
-my $newsweepvals=$current_set_valstr;
-
-my $gnuplotscript=<<"ENDS";
-set terminal X11
-
-$logscale
-#set xtics 16
-#set mxtics 2
-set grid xtics ytics mxtics mytics
-
-set key right top box 
-set key title "$legendtitle" 
-set key box
-
-set title "$title" "Helvetica,14"
-set xlabel "$sweepvartitle"
-set ylabel "$ylabel"
-
-plot '${simtempl}-${anatempl}-$newsweepvals.res'  using (\$1*1):$col title "$legend"  with linespoints lw 4 ps 2
-!sleep 1
-ENDS
-
-&gnuplot($gnuplotscript);
+    &gnuplot_combined();
 }
+} else {
+  if(not $verylast) {
+    open(RES,">$results_file_name");
+    print RES $resheader;
+    # Now add the simulation results. The difference with the raw data
+    # is that the value of $sweepvar is added as the first column.
+    foreach my $line ( @results ) {
+      print RES $line;
 }
-} # if last
-
+    close RES;
 } else {
 ### On the very last run, collect the results into one nice plot
+    &gnuplot_combined();
+  }
+}
+} #END of XYPlot
 
-#this is very critical. The quotes really matter!
-# as a rule, quotes inside gnuplot commands must be escaped
-
-my $plotlinetempl=q["\'$filename\' using (\$1*1):(\$_DATACOL/_NORM) title \"$legend\" with linespoints lw 4 ps 2"];
-if($normvar eq $sweepvar){$norm = '\$1'}
-$plotlinetempl=~s/_NORM/$norm/;
-$plotlinetempl=~s/_DATACOL/$col/;
-
-my $xtics=2;#change later
-my $firstplotline=<<"ENDH";
-set terminal postscript landscape enhanced  color solid "Helvetica" 14
-set output "${simtempl}-${anatempl}.ps"
+#------------------------------------------------------------------------------
+# This is a very generic module to generate plots from any sweep 
 
-$logscale
+sub PlotXYfromPoints {
 
-#set xtics $xtics
-#set mxtics 2
-set grid xtics ytics mxtics mytics
+  my @sweepvarvals=@{$simdata{$sweepvar}};
 
-set key right top box 
-set key title "$legendtitle" 
+  # This is to combine the values for different buffers into 1 file
+  if ($verylast==0) {
+    open(RES,">$results_file_name");
+    print RES $resheader;
+    # Now add the simulation results. The difference with the raw data
+    # is that the value of $sweepvar is added as the first column.
+    my $i=0;
+    foreach my $sweepvarval ( @sweepvarvals ) {
+      print RES "$sweepvarval\t$results[$i]";
+      $i++;
+    }
+    close RES;
+  } else {
+    # On the very last run, collect the results into one nice plot
+    # X values are in the first col, so add 1 to YCOL
+    $ycol++;
+    &gnuplot_combined();
+  }
 
-set title "$title" "Helvetica,18"
-set xlabel "$sweepvartitle" "Helvetica,16"
-set ylabel "$ylabel" "Helvetica,16"
+} #END of PlotXYfromPoints
 
-ENDH
+#------------------------------------------------------------------------------
+sub PlotXYfromRange {
 
-&gnuplot_combined($firstplotline,$plotlinetempl);
+  if($verylast) {
+    ### On the very last run, collect the results into one nice plot
+    &gnuplot_combined();
 }
 
-} #END of SweepVar()
+} #END of PlotXYfromRange()
 
 #------------------------------------------------------------------------------
-sub ErrorFlags { 
-my @args=@_;
 
-my $extra_args_ref=&prepare_plot(@args);
-my @extra_args=@{$extra_args_ref};
-my $subref=(@extra_args==1)?$extra_args[0]:0;
+sub XYPlotErrorBars { 
 
-(!@{$simdata{$normvar}})&&(${$simdata{$normvar}}[0]=1);
-#my $norm=(@{$simdata{$normvar}}>1)?${$simdata{$normvar}}[$count]:${$simdata{$normvar}}[0];
-my $norm=(@{$simdata{$normvar}}>1)?$current_set_vals{$normvar}:${$simdata{$normvar}}[0];
 my $sweepvarval=$simdata{$sweepvar}[0];
 
-#this is to combine the values for different buffers into 1 file
-#It's plain wrong: sweepvar is not part of the set vars
-#my $current_set_vals_nosweepvar=$current_set_valstr;
-#$current_set_vals_nosweepvar=~s/\-*$sweepvar\-[\d\.]+//;
-#$current_set_vals_nosweepvar=~s/^\-*//;
-
-#hook for preprocessing routine
-if($subref) {
-&{$subref}("${simtempl}_C$count.res");
-#NEW02072003#&{$subref}($results_file);
-}
-
-if($verylast==0) {
-  
-  use File::Copy;
-# with the new names, this will be obsolete
-  copy "${simtempl}_C$count.res","${simtempl}-${anatempl}-$current_set_valstr.res";
-  if($last) {
-    if($interactive) {
-      my $gnuplotscript=<<"ENDS";
-set terminal X11
-
-$logscale
-#set xtics 16
-#set mxtics 2
-set grid xtics ytics mxtics mytics
-
-set key right top box 
-set key title "$legendtitle" 
-set key box
-
-set title "$title" "Helvetica,14"
-set xlabel "$sweepvartitle"
-set ylabel "$ylabel"
-
-plot '${simtempl}-${anatempl}-$current_set_valstr.res' notitle with yerrorbars, '${simtempl}-${anatempl}-$current_set_valstr.res'  title "$legend" with lines
-!sleep 1
-ENDS
-
-      &gnuplot($gnuplotscript);
-    } # if interactive (old meaning of interactive, obsolete)
-  } # if last
-} else { #very last run
+if($verylast) {#very last run
 
 ## With NRUNS, we must wait until the very last run to calc the error flags.
 # Get all results files.
-my @allresfiles=glob("${simtempl}-${anatempl}-*.res");
 my %allresfiles=();
-foreach my $resfile (@allresfiles) {
+foreach my $resfile (@all_results_file_names) {
 $resfile!~/NRUNS/ && next;
 my $resfilenorun=$resfile;
 $resfilenorun=~s/__NRUNS-\d+/__NRUNS-/;
 $allresfiles{$resfilenorun}=1;
 }
 
-my $nruns=$simdata{'NRUNS'};
 ## Loop over all result files 
 foreach my $resfile (keys %allresfiles) {
 ## For each of these, loop over all runs
@@ -258,36 +160,23 @@
   $sweepvalsnorun=~s/\-\-/\-/g;
   $sweepvalsnorun=~s/\-$//;
 
-###Get header info. This is of course only fully correct for the last run;
-###but we use this mainly for the names of the parameters.
-### The right thing is to have SynSim use the "long" names from the start. This would make everything easier.
-#my @header=();
-#open(RES,"<${simtempl}_C$count.res")||carp "$!";
-#while(<RES>) {
-#/^\#/ && do {push @header,$_};
-#}
-#close RES;
 
 open(STAT,">$sweepvalsnorun");
-#foreach my $line (@header) {
-#  if($line!~/NRUNS/){
-#print STAT $line;
-#}
-#}
-
+  if($sweepvar) {
 foreach my $i (0..$allpoints-1) {
 open(TMP,">tmp$i.res");
   foreach my $run (1..$nruns) {
 $allruns[$run][$i]=~s/^\d+\s+//;
 print TMP $simdata{$sweepvar}->[$i],"\t",$allruns[$run][$i];
+	print  $simdata{$sweepvar}->[$i],"\t",$allruns[$run][$i];
 }
 close TMP;
-# calc average after every $count
 
+      # calc average after every $count
 my $par='PARAM';
 my %stats=%{&calc_statistics("tmp$i.res",[$par, $datacol])};
 unlink "tmp$i.res";
-my $avg=$stats{$par}{AVG}/$norm;
+      my $avg=$stats{$par}{AVG}/$normvar;
 my $stdev=$stats{$par}{STDEV}/$norm;
 #Parameter should be NSIGMAS, user can choose. As it is a postprocessing par, the syntax is 'NSIGMAS : 1.96'
 my $nsigmas=$simdata{NSIGMAS}||1.96;
@@ -296,120 +185,98 @@
 
 print STAT $simdata{$sweepvar}->[$i],"\t$avg\t$minerr\t$maxerr\n";
 }
-close STAT;
-} # all resfiles
-
-### On the very last run, collect the results into one nice plot
-
-#this is very critical. The quotes really matter!
-# as a rule, quotes inside gnuplot commands must be escaped
-
-my $plotlinetempl=q("\'$filename\' notitle with yerrorbars lt $lt, \'$filename\' title \"$legend\" with lines lt $lt");
-
-
-my $firstplotline=<<"ENDH";
-set terminal postscript landscape enhanced  color solid "Helvetica" 12
-set output "${simtempl}-${anatempl}.ps"
+} else {# no sweepvar, assuming the simulator does the sweep
+  my @tmpres=();
+  my $i=0;
+  foreach my $run (1..$nruns) {
+    $i=0;
+    foreach (@{$allruns[$run]}) {
+      /^\s+$/ && next;
+      /^\s*\#/ && next;
+      chomp;
+      s/\s+$//;
+      s/^\s+//;
+      my @row=split(/[\s\t]+/,$_);
+      push @{$tmpres[$i]},$row[$datacol-1];
+      $i++;
+    }
+  }
+  my $itot=$i;
+  $i=0;
 
-$logscale
+  while ($i<$itot) {
+    open(TMP,">tmp$i.res");
+    foreach my $item (@{$tmpres[$i]}) {
+      print TMP "$item\n";
+    }
+    close TMP;
+    # calc average after every $count
+    my $par='PARAM';
+    my %stats=%{&calc_statistics("tmp$i.res",[$par, 1])};
+    unlink "tmp$i.res";
+    my $avg=$stats{$par}{AVG}/$normvar;
+    my $stdev=$stats{$par}{STDEV}/$normvar;
+    #Parameter should be NSIGMAS, user can choose. As it is a postprocessing par, the syntax is 'NSIGMAS : 1.96'
+    my $nsigmas=$simdata{NSIGMAS}||1.96;
+    my $minerr=$avg-$nsigmas*$stdev; # 2 sigma = 95% MAKE THIS A PARAMETER! CONFIDENCE
+    my $maxerr=$avg+$nsigmas*$stdev; # 2 sigma = 95%
 
-#set xtics 16
-#set mxtics 2
-set grid xtics ytics mxtics mytics
+    print STAT "$i\t$avg\t$minerr\t$maxerr\n";
+    $i++;
+  }
 
-set key right top box 
-set key title "$legendtitle" 
+} # no SWEEPVAR
 
-set title "$title" "Helvetica,14"
-set xlabel "$sweepvartitle"
-set ylabel "$ylabel"
+close STAT;
+} # all resfiles
 
-ENDH
+### On the very last run, collect the results into one nice plot
 
-&gnuplot_combined($firstplotline,$plotlinetempl);
+&gnuplot_combined();
 }
 
-} #END of ErrorFlags()
+} #END of XYPlotErrorBars()
 
 #------------------------------------------------------------------------------
 
 sub Histogram {
 
-my @args=@_;
-
-my $extra_args_ref=&prepare_plot(@args);
-my @extra_args=@{$extra_args_ref};
-my $subref=(@extra_args==1)?$extra_args[0]:0;
-
-my $plotstyle=($style ne '')?$style:'boxes';
 my $sweepvarval=${$simdata{$sweepvar}}[0]; # used for nbins?!
 my $nbins=$simdata{NBINS}||20;
 my $binwidth=$simdata{BINWIDTH}||1;
-my $min=0;
-my $max=$min+$nbins*$binwidth;
+my $min=$simdata{MIN}||'CALC';# was 0
+my $max=$simdata{MAX}||'CALC';#was ($min+$nbins*$binwidth);
 my $par='DATA';#must be "LOG" for log plot
 my $log=''; #must be 'log' for log plot
 #carp "LOGSCALE: $logscale\n";
-my @logscale=split("\n",$logscale);
-if($logscale[1]=~/x/i) {
+#my @logscale=split("\n",$logscale);
+#if($logscale[1]=~/x/i) {
+if($logscale!~/nologscale/ and $logscale=~/x/i) {
 $xstart=($xstart&&$xstart>0)?log($xstart)/log(10):'';
 $xstop=($xstart&&$xstop>0)?log($xstop)/log(10):'';
-  $logscale[1]=~s/x//i;
-  $logscale="$logscale[0]\n$logscale[1]\n";
+#  $logscale[1]=~s/x//i;
+#  $logscale="$logscale[0]\n$logscale[1]\n";
+$logscale=~s/x//i;
   $par='LOG';#'DATA';#must be "LOG" for log plot
   $log='log'
 }
 #carp "LOGSCALE: $logscale\n";
 
-#hook for preprocessing routine
-if($subref) {
-&$subref("${simtempl}_C$count.res");
-#NEW02072003#&{$subref}($results_file);
-}
+  if(not $verylast) {
+my %hists=%{&build_histograms($results_file_name,[$par,$datacol],$title,$log,$nbins,$min,$max)};
 
-  if($verylast==0) {
-#my %hists=%{&build_histograms("${simtempl}_C$count.res",[$par,$datacol],$title,$log,$sweepvarval)};
-my %hists=%{&build_histograms("${simtempl}_C$count.res",[$par,$datacol],$title,$log,$nbins,$min,$max)};
-#NEW02072003#my %hists=%{&build_histograms($results_file,[$par,$datacol],$title,$log,$nbins,$min,$max)};
-
-#system("grep '#' ${simtempl}_C$count.res > ${simtempl}-${anatempl}-$current_set_valstr.res");
-&egrep('#',"${simtempl}_C$count.res",'>',"${simtempl}-${anatempl}-$current_set_valstr.res");
-
-#NEW02072003#&egrep('#',$results_file,'>',"tmp$results_file");
-#NEW02072003#rename "tmp$results_file",$results_file;
-
-open HIST,">>${simtempl}-${anatempl}-$current_set_valstr.res";
+&egrep('#',$results_file_name,'>',"tmp$results_file_name");
+rename("tmp$results_file_name",$results_file_name);
+open HIST,">$results_file_name";
 foreach my $pair (@{$hists{$par}}) {
 print HIST $pair->{BIN},"\t",$pair->{COUNT},"\n";
 }
 close HIST;
-if($interactive) {
-#&gnuplot( "plot '${simtempl}-${anatempl}-$current_set_valstr.res' with $plotstyle\n\!sleep 1\n");
-}
-} else {
-my $plotlinetempl=q("\'$filename\' title \"$legend\" with ).$plotstyle.q(");
-
-my $firstplotline=<<"ENDH";
-set terminal postscript landscape enhanced  color solid "Helvetica" 12
-set output "${simtempl}-${anatempl}.ps"
-
-$logscale
-
-#set xtics 2
-#set mxtics 2
-set grid xtics ytics mxtics mytics
-
-set key right top box 
-set key title "$legendtitle" 
 
-set title "$title" "Helvetica,14"
-set xlabel "$sweepvartitle"
-set ylabel "$ylabel"
-
-plot [$xstart:$xstop]\\
-ENDH
-
-&gnuplot_combined($firstplotline,$plotlinetempl);
+} else {
+$xcol=1;
+$ycol=2;
+&gnuplot_combined();
 
 }
 
@@ -417,160 +284,89 @@
 } #END of Histogram()
 
 #------------------------------------------------------------------------------
-# Sweep a variable until a condition is met, then save the result; then maybe skip all other values in sweep; and later maybe allow to iterate to refine solution.
+
 my %condval=();
 
-sub SweepVarCond {
-  my @args=@_;
-  my $extra_args_ref=&prepare_plot(@args);
-  my @extra_args=@{$extra_args_ref};
-  my $subref=(@extra_args==1)?$extra_args[0]:0;
-
-  my $plotstyle=($style ne '')?$style:'linespoints';
-  (!@{$simdata{$normvar}})&&(${$simdata{$normvar}}[0]=1);
-  #my $norm=(@{$simdata{$normvar}}>1)?${$simdata{$normvar}}[$count]:${$simdata{$normvar}}[0];
-  my $norm=(@{$simdata{$normvar}}>1)?$current_set_vals{$normvar}:${$simdata{$normvar}}[0];
-  my $col=$datacol+1;
-
-  my $notsetvarstr=$current_set_valstr;
-  $notsetvarstr=~s/$setvar\-[\w\.]+//;
-  $notsetvarstr=~s/^\-//;
-#WV 17072003: NOt sure about this ...
-  $notsetvarstr=~s/\-\-/\-/g;
-  my @sweepvarvals=@{$simdata{$sweepvar}};
+sub CondXYPlot {
 
-#hook for preprocessing routine
-if($subref) {
-&{$subref}("${simtempl}_C$count.res");
-#NEW02072003#&{$subref}($results_file);
-}
-#this is to combine the values for different values of $sweepvar into 1 file
 
-if($verylast==0) {
+# For every corner in the DOE:
+
+  #The values of the conditional variable
+  my @condvarvals=@{$simdata{$condvar}};
 
+  # remove the original results file. data are in @results, so no need for it
+  # and otherwise the files appear in the final plot
+  unlink $results_file_name;
+
+ if(not $verylast) { # The DOE is not finished yet 
 my $condition_met=0;
 my $i=0;
-foreach my $sweepvarval ( @sweepvarvals ) {
+    #This is the core routine to check the condition
+    foreach my $condvarval ( @condvarvals ) { # @condvarvals and @results have the same length
 my @line=split(/\s+/,$results[$i]);
 $i++;
 my $value=$line[$datacol-1];
 if( !$condition_met && eval("$value$cond")) {
 $condition_met=1;
 my $setvarval=$current_set_vals{$setvar};
-push @{$condval{$notsetvarstr}},"$setvarval $sweepvarval";
+	push @{$condval{$current_set_except_setvar_str}},"$setvarval $condvarval";
 }
-
 } # all results for current sweep
 
-if($last) { # SETVAR is defined and the element in the value list has been reached. Usually, this is not the case
+    if ($last) { # The X-axis sweep for the current set of parameters is finished.
 
   foreach my $valstr (keys %condval) {
-
-    # create the header (basically, only comments)
-    my $resheader='';
-    open(IN,"<${simtempl}_C$count.res");
-    #NEW02072003#open(IN,"<$results_file");
-    
-    while(<IN>) {
-      /\#/ && !/Parameters|$sweepvar/ && do {
-	#print HEAD $_
-	$resheader.=$_;
-      };
-    }
-    close IN;
-    open(HEAD,">${simtempl}-${anatempl}-${valstr}.res");
-    print HEAD $resheader;
-    close HEAD;
-    
-    # add values
-    open(RES,">>${simtempl}-${anatempl}-${valstr}.res");
+	  my $new_results_file_name=$results_file_name;
+	  $new_results_file_name=~s/$current_set_str/$valstr/;
+	  open(RES,">$new_results_file_name");
+	  print RES $resheader;
     foreach my $line (@{$condval{$valstr}}) {
       print RES "$line\n";
     }
     close RES;
-    
-    #  if($interactive) {
-    #      my $gnuplotscript=<<"ENDS";
-    #set terminal X11
-    
-    #$logscale
-
-    #set grid xtics ytics mxtics mytics
-
-    #set key right top box 
-    #set key title "$legendtitle" 
-    #set key box
-
-    #set title "$title" "Helvetica,14"
-    #set xlabel "$sweepvartitle"
-    #set ylabel "$ylabel"
-
-    #plot '${simtempl}-${anatempl}-$valstr.res'  using (\$1*1):2 title "$legend"  with lines
-    #!sleep 1
-    #ENDS
-    #      &gnuplot($gnuplotscript);
-    
-    #  } # if interactive
   }
-
-
-
-
 } # if last
-
-# in case of Cond: we sweep _NBUFS, the set is _NEXITS, the final plot is (_NBUFS for COND) vs _NEXITS
-# so we need SETVAR: _NEXITS
-# and for every last SETVAR, we create the file for gnuplot
-# but if there are other vars, this means the gnuplot file will have more than one value!?
-# so we must check the values of the other variables, and split into separate files.
-
-} else { 
-### On the very last run, collect the results into one nice plot
-
-#this is very critical. The quotes really matter!
-# as a rule, quotes inside gnuplot commands must be escaped
-
-my $plotlinetempl=q("\'$filename\' using (\$1*1):(\$2*1) title \"$legend\" with ).$plotstyle.q(");
-if($normvar eq $sweepvar){$norm = '\$1'}
-$plotlinetempl=~s/_NORM/$norm/;
-$plotlinetempl=~s/_DATACOL/$col/;
-
-my $xtics=2;#change later
-my $firstplotline=<<"ENDH";
-set terminal postscript landscape enhanced  color solid "Helvetica" 14
-set output "${simtempl}-${anatempl}.ps"
-
-$logscale
-
-#set xtics $xtics
-#set mxtics 2
-set grid xtics ytics mxtics mytics
-
-set key right top box 
-set key title "$legendtitle" 
-
-set title "$title" "Helvetica,18"
-set xlabel "$sweepvartitle" "Helvetica,16"
-set ylabel "$ylabel" "Helvetica,16"
-
-ENDH
-
-&gnuplot_combined($firstplotline,$plotlinetempl);
+  } else { ### On the very last run, collect the results into one nice plot
+    $ycol++;
+    &gnuplot_combined();
 }
 
-} #END of SweepVarCond()
+} #END of CondXYPlot()
 #------------------------------------------------------------------------------
 
-sub None {
-}
 #==============================================================================
 #
+# PREPROCESSORS
+#
 # Routines for pre-processing of results 
-# All these routines receive the filename of the raw results file as arg
-# (typically ${simtempl}_C$count.res )
-# and must modify this file in-place (e.g. via a temp file tmp.res)
+# All these routines modify the @results array, which is the raw data from the simulator in a line-by-line array
 #
-
+sub show_results {
+  print STDERR "RESULTS:\n";
+  for my $line (@results){
+    print STDERR $line;
+  }
+  print STDERR "-" x 78;
+  print STDERR "\n";
+}
+#------------------------------------------------------------------------------
+sub clean_up {
+  for my $line (@results) {
+($line=~/^\s*\#/) && next;
+    $line=~s/^.*\:\s*//;
+  }
+}
+#------------------------------------------------------------------------------
+sub square {
+print "Calling square():\n" if $verbose;
+  for my $line (@results){
+chomp $line;
+$line*=$line;
+$line.="\n";
+}
+}
+#------------------------------------------------------------------------------
 sub get_train_lengths {
 my $resultsfile=shift;
 my $nports=$simdata{_NPORTS}->[0];
@@ -581,19 +377,18 @@
 foreach my $dest (0..$nports-1) {
   $train_length[$dest]=0;
 }
-open(IN,"<$resultsfile") or die $!;
-open(TMP,">$resultsfile.tmp");
-while(<IN>) {
-if(!/^DEST/){
-print TMP $_;
+
+foreach my $line (@results){
+if($line!~/^DEST/){
+print TMP $line;
 } else {
-  chomp(my $dest=$_);
+  chomp(my $dest=$line);
   $dest=~s/^.*\s+//;
   if($dest == $prevdest) {
     $train_length[$dest]++;
   } else {
-    chomp;
-    s/\d+$//;
+    chomp $line;
+    $line=~s/\d+$//;
     print TMP "$_\t",$train_length[$prevdest],"\n";
     foreach my $dest (0..$nports-1) {
       $train_length[$dest]=0;
@@ -603,10 +398,6 @@
   }
 }
 }
-close IN;
-close TMP;
-
-rename "$resultsfile.tmp","$resultsfile" or die $!;
 
 }
 #==============================================================================
diff -r -b -B --ignore-all-space -u Simulation-Automate-0.9.7/Automate/PostProcLib.pm Simulation-Automate-1.0.0/Automate/PostProcLib.pm
--- Simulation-Automate-0.9.7/Automate/PostProcLib.pm	2003-09-04 11:04:52.000000000 +0000
+++ Simulation-Automate-1.0.0/Automate/PostProcLib.pm	2004-01-05 11:11:56.000000000 +0000
@@ -1,7 +1,7 @@
 package Simulation::Automate::PostProcLib;
 
 use vars qw( $VERSION );
-$VERSION = "0.9.6";
+$VERSION = "1.0.0";
 
 ################################################################################
 #                                                                              #
@@ -21,59 +21,34 @@
 $Id: PostProcLib.pm,v 1.2 2003/09/04 09:54:19 wim Exp $
 
 =cut
-
-use sigtrap qw(die untrapped normal-signals
-               stack-trace any error-signals); 
+use warnings;
 use strict;
 use Carp;
-use FileHandle;
+#use FileHandle;
 use Exporter;
 use lib '.','..';
 
 use Simulation::Automate::Analysis;
 use Simulation::Automate::Dictionary;
-
+#use Simulation::Automate::PostProcessors;
 @Simulation::Automate::PostProcLib::ISA = qw(Exporter);
 @Simulation::Automate::PostProcLib::EXPORT = qw(
 			   &prepare_plot
+						&prepare
 			   &gnuplot
 			   &gnuplot_combined
-			   &copy_results
-			   &create_legend
 			   %simdata
 			   $last
 			   $verylast
-			   $current_set_valstr
-			   $results_file
+						$every_sweep_val
+						$current_set_str
+						$current_set_except_setvar_str
+						$results_file_name
+						@all_results_file_names
  			   %current_set_vals					       
-			   %sweepvals					       
-			   $sweepvals					       
-			   $sweepvar
-			   $setvar
-			   $normvar
-			   $cond
-			   $sweepvartitle
-			   $plot
-			   $interactive
-			   $title
-			   $datacol
-			   $count
-			   $simtempl
-			   $anatempl
-			   $dirname
-			   $legend
-			   $legendtitle
-			  $xlabel
-			  $ylabel
-			  $logscale
-			  $style
-			  $xstart
-			  $xstop
-			  $ystart
-			  $ystop
-			  $xtics
-			  $ytics
 			  @results
+						&import_symbols
+						$verbose
 			  );
 
 ##################################################################################
@@ -91,93 +65,194 @@
 }
 
 #------------------------------------------------------------------------------
-
-sub prepare_plot {
+sub prepare {
+#print "Entering prepare()\n";
   use Cwd;
+
   #*&Simulation::Automate::PostProcessors::$subref(\$dataset,\$i,\$dataref1,\$flagsref,\$returnvalue,\$preprocref);
   #&prepare_plot(@args);
-  my $dataset=shift;
-  $Simulation::Automate::PostProcLib::count=shift;
+#  print "PREPARE\n";
+  my $datafile_name=shift;
+  my $count=shift;
   my $dataref=shift;
   my $flagsref=shift;
   my $verylastref=shift;
+  my @extra_args=@_;
 
-  if($verylastref!=1){
-    @Simulation::Automate::PostProcLib::results=@{$verylastref};
-    $Simulation::Automate::PostProcLib::verylast=0;
-  } else {
-    @Simulation::Automate::PostProcLib::results=();
-    $Simulation::Automate::PostProcLib::verylast=1;
+  my $preprocref=((@extra_args>=1) && $extra_args[0])?$extra_args[0]:0;
+  
+  my $every_sweep_val=((@extra_args==2) && ($extra_args[1]==2))?1:0;
+  my $verylast=1;
+  my @results=();
+
+  if($verylastref && $verylastref!=1){
+    @results=@{$verylastref};
+     $verylast=0;
   }
 
-  (my $batch,$Simulation::Automate::PostProcLib::interactive,my $nosims,$Simulation::Automate::PostProcLib::plot,my $verbose)=@{$flagsref};
+  (my $batch, $Simulation::Automate::PostProcLib::interactive,my $nosims,$Simulation::Automate::PostProcLib::plot,$Simulation::Automate::PostProcLib::verbose)=@{$flagsref};
   my $copy_results=1;
-  #*my \$dataref1 = [\$nsims,\\\%data,\\\%sweepeddata,\\\%last];
   (my $nsims, my $simdataref,my $current_set_valsref,my $lastref)=@{$dataref};
   
-  %Simulation::Automate::PostProcLib::simdata=%{$simdataref};
-#current_set_vals is actually "the current values in the sweep", so current_set_vals would a better name
+  my %synsimdata=%{$simdataref};
   my %current_set_vals=%{$current_set_valsref};
-  $Simulation::Automate::PostProcLib::sweepvals='';
+#to be exported: current_set_str
+  my $current_set_str='';
   foreach my $key (sort keys %current_set_vals) {
-    $Simulation::Automate::PostProcLib::sweepvals.="${key}-".$current_set_vals{$key}.'-';
+    $current_set_str.="${key}-".$current_set_vals{$key}.'-';
   }
-  $Simulation::Automate::PostProcLib::sweepvals=~s/-$//;
-  my @current_set_vals=sort keys %current_set_vals; # not used
-  %Simulation::Automate::PostProcLib::current_set_vals=%current_set_vals;
-  $Simulation::Automate::PostProcLib::current_set_valstr=$Simulation::Automate::PostProcLib::sweepvals;
-  $Simulation::Automate::PostProcLib::cond=$Simulation::Automate::PostProcLib::simdata{COND}||'<1';
-  my $setvar=$Simulation::Automate::PostProcLib::simdata{SETVAR}||'none';
-  $Simulation::Automate::PostProcLib::setvar=$setvar;
-  #  my $setvarval=${$Simulation::Automate::PostProcLib::simdata{$setvar}}[0]; # if SETVAR is defined, this would be the first value in the list for SETVAR. This is to used check if the last element in the SETVAR value list has been reached
-  my $setvarval=$Simulation::Automate::PostProcLib::simdata{$setvar}->[0]; # if SETVAR is defined, this would be the first value in the list for SETVAR. This is to used check if the last element in the SETVAR value list has been reached
+  $current_set_str=~s/-$//;
+
+#The idea is to use XVAR or SWEEPVAR for any X-value sweep. As there is no longer a requirement to have semicol-lists for grouping, if XVAR is not semicol, make it semicol.
+#If there was a semicol-list, make it comma. 
+#If there were 2 or more semicol lists, add them to %grouped
+#CONDVAR must only be defined if a CONDITION is present. In this case, CONDVAR is swept, XVAR is stepped, so XVAR should be a comma-separated list. If not, make it one. Again, if semicol grouping is used, convert to new grouping
+#So, internally:
+#(COND or CONDITION) {
+#XVAR=SETVAR
+#SWEEPVAR=CONDVAR
+#} else {
+#XVAR=SWEEPVAR
+#}
+
+
+  my $setvar=$synsimdata{SETVAR}||'';
+  if(exists $synsimdata{COND} or exists $synsimdata{CONDITION}) {
+    my $condvar= $synsimdata{CONDVAR}||$synsimdata{SWEEPVAR}||'none';
+    $synsimdata{CONDVAR}=$synsimdata{SWEEPVAR}=$condvar;
+    my $xvar= $synsimdata{XVAR}|| $synsimdata{SETVAR}||'';
+    $synsimdata{XVAR}=$synsimdata{SETVAR}=$xvar;
+    $setvar=$xvar;
+  } else {
+    my $xvar= $synsimdata{XVAR}|| $synsimdata{SWEEPVAR}||'';
+    $synsimdata{XVAR}=$synsimdata{SWEEPVAR}=$xvar;
+  }
+
+  my $cond=$synsimdata{COND}||$synsimdata{CONDITION}||'<1';
+  $synsimdata{COND}=$synsimdata{CONDITION}=$cond;
+
+  my $setvarval=$synsimdata{$setvar}->[0]; # if SETVAR is defined, this would be the first value in the list for SETVAR. This is to used check if the last element in the SETVAR value list has been reached
+my $current_set_except_setvar_str=$current_set_str;
+my $setvar_str=($setvar ne '')?$setvar.'-'.$setvarval:'';
+$current_set_except_setvar_str=~s/$setvar_str\-*//;
 
   my %last=%{$lastref}; # the last value in the list for every variable
-  $Simulation::Automate::PostProcLib::last=($setvar ne 'none' && $setvarval==$last{$setvar}); # SETVAR is defined and the element in the value list has been reached. 
 
-  my $pattern=$Simulation::Automate::PostProcLib::simdata{OUTPUT_FILTER_PATTERN}|| '.*';
-  my $devtype=$Simulation::Automate::PostProcLib::simdata{DEVTYPE};
-  my $ext=$Simulation::Automate::PostProcLib::simdata{TEMPL};
-  $Simulation::Automate::PostProcLib::sweepvar=$Simulation::Automate::PostProcLib::simdata{SWEEPVAR}||'none';
-  $Simulation::Automate::PostProcLib::normvar=$Simulation::Automate::PostProcLib::simdata{NORMVAR}||'none';
-  $Simulation::Automate::PostProcLib::datacol=$Simulation::Automate::PostProcLib::simdata{DATACOL}||1;
-  $Simulation::Automate::PostProcLib::simtempl=$Simulation::Automate::PostProcLib::simdata{SIMTYPE};
-  $Simulation::Automate::PostProcLib::dirname= "${Simulation::Automate::PostProcLib::simtempl}-$dataset";
-  $Simulation::Automate::PostProcLib::anatempl=$Simulation::Automate::PostProcLib::simdata{ANALYSIS_TEMPLATE};
-  $Simulation::Automate::PostProcLib::results_file=$Simulation::Automate::PostProcLib::simtempl.'-'.$Simulation::Automate::PostProcLib::anatempl.'-'.$Simulation::Automate::PostProcLib::current_set_valstr.'.res';
-  $Simulation::Automate::PostProcLib::title=$Simulation::Automate::PostProcLib::simdata{TITLE}||"$devtype $Simulation::Automate::PostProcLib::simtempl simulation";
+  my $last=($setvar && (exists $last{$setvar}) && ($setvar ne '') && $setvarval && ($setvarval==$last{$setvar})); # SETVAR is defined and the element in the value list has been reached. 
+
+  $synsimdata{OUTPUT_FILTER_PATTERN}||= '.*';
+
+  my $plotext=$synsimdata{PLOTTEMPL}||$synsimdata{PLOTTEMPLATE}||$synsimdata{PLOT_TEMPLATE}||'.gnuplot';
+  $synsimdata{PLOTTEMPL}=$synsimdata{PLOTTEMPLATE}=$synsimdata{PLOT_TEMPLATE}=$plotext;
+
+  $synsimdata{PLOTCOMMAND}||='/usr/bin/ggv';
+  if((not -e '/usr/bin/ggv') and ( -e '/usr/X11R6/bin/gv')) {
+  $synsimdata{PLOTCOMMAND}||='/usr/X11R6/bin/gv';
+  }
+  my $normvar=$synsimdata{NORMVAR}||1;
+  (!$synsimdata{$normvar} || !@{$synsimdata{$normvar}})&&(${$synsimdata{$normvar}}[0]=1);
+  my $current_norm_val=(@{$synsimdata{$normvar}}>1)?$current_set_vals{$normvar}:${$synsimdata{$normvar}}[0];
+  $synsimdata{NORMVAR}=$normvar;
+
+(exists $synsimdata{XVAR}) && ($synsimdata{XCOL}||=1);
+  my $datacol=$synsimdata{DATACOL}||$synsimdata{YCOL}||1;
+  $synsimdata{DATACOL}=$synsimdata{YCOL}=$datacol;
+
+  my $simtempl=$synsimdata{SIMULATION}||$synsimdata{SIMNAME}||$synsimdata{SIMTYPE}||$synsimdata{TEMPLATE}||$synsimdata{SIMTEMPL};
+  $synsimdata{SIMULATION}=$synsimdata{SIMNAME}=$synsimdata{SIMTYPE}=$synsimdata{TEMPLATE}=$synsimdata{SIMTEMPL}=$simtempl;
+
+  my $anatempl=$synsimdata{ANALYSIS_TEMPLATE}||$synsimdata{ANALYSIS}||$synsimdata{ANATEMPL}||'None';
+  $synsimdata{ANALYSIS_TEMPLATE}=$synsimdata{ANALYSIS}=$synsimdata{ANATEMPL}=$anatempl;
 
-  my $simtitle=$Simulation::Automate::PostProcLib::title;
-  foreach my $key (keys %Simulation::Automate::PostProcLib::simdata) {
+  my $results_file_name=$simtempl.'-'.$anatempl.'-'.$current_set_str.'.res';
+
+  #NEW 24/11/2003 Copy "old" results files to new names
+  if(not $verylast){
+    system("cp ${simtempl}_C${count}.res $results_file_name");
+}
+  my $devtype=$synsimdata{DEVTYPE}|| $synsimdata{DEVICE}||'';
+  $synsimdata{DEVTYPE}=$synsimdata{DEVICE}=$devtype;
+  $synsimdata{TITLE}||="$devtype $simtempl simulation";
+  my $simtitle = my $title = $synsimdata{TITLE};
+  foreach my $key (keys %synsimdata) {
     ($key!~/^_/) && next;
     ($simtitle=~/$key/) && do {
-      my $val=$Simulation::Automate::PostProcLib::simdata{$key};
+      my $val=$synsimdata{$key};
       my $nicekey=$make_nice{$key}{title}||&make_nice($key);
       my $niceval=$make_nice{$key}{${$val}[0]}||join(',',@{$val});
       $simtitle=~s/$key/$nicekey:\ $niceval/;
     };
-    $Simulation::Automate::PostProcLib::title=$simtitle;
+    $title=$simtitle;
 }
+
 # For Gnuplot
 #XSTART, XSTOP, YSTART, YSTOP, XTICS, YTICS, YLABEL, XLABEL, LOGSCALE, STYLE,
-$Simulation::Automate::PostProcLib::xstart=$Simulation::Automate::PostProcLib::simdata{XSTART}||"";
-$Simulation::Automate::PostProcLib::xstop=$Simulation::Automate::PostProcLib::simdata{XSTOP}||"";
-$Simulation::Automate::PostProcLib::ystart=$Simulation::Automate::PostProcLib::simdata{YSTART}||"";
-$Simulation::Automate::PostProcLib::ystop=$Simulation::Automate::PostProcLib::simdata{YSTOP}||"";
-$Simulation::Automate::PostProcLib::xtics=$Simulation::Automate::PostProcLib::simdata{XTICS}||"";
-$Simulation::Automate::PostProcLib::ytics=$Simulation::Automate::PostProcLib::simdata{YTICS}||"";
-$Simulation::Automate::PostProcLib::ylabel=$Simulation::Automate::PostProcLib::simdata{YLABEL}||"$Simulation::Automate::PostProcLib::title";
-$Simulation::Automate::PostProcLib::xlabel=$Simulation::Automate::PostProcLib::simdata{XLABEL}||"$Simulation::Automate::PostProcLib::title";
-$Simulation::Automate::PostProcLib::logscale=($Simulation::Automate::PostProcLib::simdata{LOGSCALE})?"set nologscale xy\nset logscale ".lc($Simulation::Automate::PostProcLib::simdata{LOGSCALE}):'set nologscale xy';
-$Simulation::Automate::PostProcLib::style=$Simulation::Automate::PostProcLib::simdata{STYLE}||'';
+  $synsimdata{XSTART}||="";
+  $synsimdata{XSTOP}||="";
+  $synsimdata{YSTART}||="";
+  $synsimdata{YSTOP}||="";
+  $synsimdata{XTICS}||="";
+  $synsimdata{YTICS}||="";
+  $synsimdata{YLABEL}||="$title";
+  $synsimdata{XLABEL}||=&make_nice($synsimdata{XVAR});#"$title";
+  $synsimdata{LOGSCALE}=($synsimdata{LOGSCALE})?"set nologscale xy\nset logscale ".lc($synsimdata{LOGSCALE}):'set nologscale xy';
+  my $plotstyle=$synsimdata{PLOTSTYLE}||$synsimdata{STYLE}||'linespoints';
+  $synsimdata{PLOTSTYLE}=$synsimdata{STYLE}=$plotstyle;
+  $synsimdata{DATAFILENAME}=$datafile_name;
+  (my $legendtitle, my $legend)=@{&create_legend($current_set_str,\%make_nice)};
+  my @all_results_file_names=glob($simtempl.'-'.$anatempl.'*.res');
+
+  @Simulation::Automate::PostProcLib::all_results_file_names=@all_results_file_names;
+  @Simulation::Automate::PostProcLib::results=@results;
+  %Simulation::Automate::PostProcLib::simdata=%synsimdata;
+  %Simulation::Automate::PostProcLib::current_set_vals=%current_set_vals;
+  $Simulation::Automate::PostProcLib::results_file_name=$results_file_name;
+  $Simulation::Automate::PostProcLib::current_set_str=$current_set_str;
+  $Simulation::Automate::PostProcLib::current_set_except_setvar_str=$current_set_except_setvar_str;
+  $Simulation::Automate::PostProcLib::verylast=$verylast;
+  $Simulation::Automate::PostProcLib::last=$last;
+  $Simulation::Automate::PostProcLib::simtempl=$simtempl;
+  $Simulation::Automate::PostProcLib::anatempl=$anatempl;
+  $Simulation::Automate::PostProcLib::plotext=$plotext;
+#  if ($preprocref!=0) {
+#    eval('use Simulation::Automate::PostProcessors;');
+#    &{$preprocref}();
+#  }
+#%Simulation::Automate::PostProcessors::simdata=%synsimdata;
+#@Simulation::Automate::PostProcessors::results=@results;
+
+&import_symbols();
+my $postprocpath= $INC{"Simulation/Automate/PostProcLib.pm"};
+$postprocpath=~s/Lib/essors/;
+($postprocpath=~/^\./)&&($postprocpath='../'.$postprocpath);
+require $postprocpath;
 
-$Simulation::Automate::PostProcLib::sweepvartitle=$Simulation::Automate::PostProcLib::xlabel||$make_nice{$Simulation::Automate::PostProcLib::sweepvar}{title}||$Simulation::Automate::PostProcLib::xlabel||$Simulation::Automate::PostProcLib::sweepvar;
-($Simulation::Automate::PostProcLib::legendtitle, $Simulation::Automate::PostProcLib::legend)=@{&create_legend($Simulation::Automate::PostProcLib::sweepvals,\%make_nice)};
+my $workingdir=cwd();
+if( -d "../PLUGINS") {
+  my @preprocs=glob("../PLUGINS/*.pm");
+  foreach my $plugin (@preprocs) {
+    if($synsimdata{PREPROCESSOR} && ($plugin=~/$synsimdata{PREPROCESSOR}/) or $synsimdata{POSTPROCESSOR} && ($plugin=~/$synsimdata{POSTPROCESSOR}/)) {
+      require $plugin;
+    }
+  }
+}
+if(exists $synsimdata{PREPROCESSOR}) {
+#print "Calling preprocessor $synsimdata{PREPROCESSOR} from prepare\n";
+#@_= @Simulation::Automate::PostProcLib::results;
+ eval('&Simulation::Automate::PostProcessors::'.$synsimdata{PREPROCESSOR});#.'(@_)');
+# @Simulation::Automate::PostProcLib::results=@_;
+}
+
+#print "Calling Simulation::Automate::PostProcessors::$synsimdata{ANATEMPL} from prepare\n";
+if( $synsimdata{ANATEMPL} ne 'None' ) {
+eval('&Simulation::Automate::PostProcessors::'.$synsimdata{ANATEMPL});
+}
+
+#print "Leaving prepare()\n";
 return [@_];
-} # END of prepare_plot()
+} # END of prepare()
 
 #------------------------------------------------------------------------------
-
 sub gnuplot {
 my $commands=shift;
 my $persist=shift||'';
@@ -189,13 +264,23 @@
 } # END of gnuplot()
 #------------------------------------------------------------------------------
 sub gnuplot_combined {
-my $firstplotline=shift;
-my $plotlinetempl=shift;
-my $col=$Simulation::Automate::PostProcLib::datacol;
-#my %make_nice=%{shift(@_)};
+#my $firstplotline=shift||'';
+#my $plotlinetempl=shift||'';
+#my $col=$Simulation::Automate::PostProcLib::datacol;
+#my $ycol=$Simulation::Automate::PostProcLib::ycol;
+#if($firstplotline=~/^\d+$/) {
+#$ycol=$firstplotline;
+#$firstplotline='';
+#}
+my $firstplotline='';
+my $plotlinetempl='';
+#my $synsimdataref=shift;
+#my %synsimdata=%Simulation::Automate::PostProcLib::synsimdata;
+my %synsimdata=%Simulation::Automate::PostProcLib::simdata;
+$synsimdata{YCOL}= $Simulation::Automate::PostProcLib::ycol;
+
 ### On the very last run, collect the results 
 #1. get a list of all plot files
-
 my @plotfiles=glob("${Simulation::Automate::PostProcLib::simtempl}-${Simulation::Automate::PostProcLib::anatempl}-*.res");
 
 #2. create a gnuplot script 
@@ -203,6 +288,7 @@
 my @lines=();
 my $legendtitle='';
 my $lt=0;
+my $range='';
 foreach my $filename (@plotfiles) {
 $lt++;
 my $title=$filename;
@@ -206,9 +292,31 @@
 foreach my $filename (@plotfiles) {
 $lt++;
 my $title=$filename;
+
 $title=~s/${Simulation::Automate::PostProcLib::simtempl}-${Simulation::Automate::PostProcLib::anatempl}-//;
 $title=~s/\.res//;
-my %title=split('-',$title);
+$title=~s/\-\-/\-\_MINUS_/g;
+#(my $legendkey,my $legendvalue)=split('-',$title);
+my %legend=split('-',$title);
+my @legendkeys=();
+my @legendvalues=();
+foreach  my $varname (sort keys %legend){
+push @legendkeys,$varname;
+push @legendvalues,$legend{$varname};
+}
+my $legendkey='';
+$legendkey.=join(', ',@legendkeys);
+my $legendvalue='';
+$legendvalue.=join(', ', @legendvalues);
+
+#$legendkey||=' ';
+($legendkey eq '') && ( $legendkey=' ');
+($legendvalue eq '') && ($legendvalue=' ');
+#($legendvalue=~/^\d+$/)&&($legendvalue!=0) && ($legendvalue||=' ');
+($legendkey=~/_MINUS_/)&&($legendkey=~s/_MINUS_/\-/g);
+($legendvalue=~/_MINUS_/)&&($legendvalue=~s/_MINUS_/\-/g);
+
+my %title= ($legendkey=>$legendvalue);
 
 my $legend='';
 $legendtitle='';
@@ -220,15 +328,21 @@
 }
 $legend=~s/,$//;
 $legendtitle=~s/^,//;
+$synsimdata{LEGEND}=$legend;
+$synsimdata{LEGENDTITLE}=$legendtitle;
+
+if(($firstplotline eq '') and ($plotlinetempl eq '')){
+($firstplotline, $plotlinetempl,$range)=@{&parse_gnuplot_templ(\%synsimdata)};
+}
 
 my $plotline;
-#carp '$plotline='.$plotlinetempl;
+#print "PLOTLINE:", '$plotline='.$plotlinetempl;
 eval('$plotline='.$plotlinetempl);
 #carp "PLOTLINE:$plotline";
 push @lines, $plotline
 }
 $firstplotline=~s/set\s+key\s+title.*/set key title "$legendtitle"/;
-my $plot="\nplot ";
+my $plot="\nplot $range ";
 if($firstplotline=~/$plot/ms){$plot=''};
 my $line=$firstplotline.$plot.join(",\\\n",@lines);
 
@@ -242,10 +356,117 @@
 close GNUPLOT;
 
 if($Simulation::Automate::PostProcLib::interactive) {
-system("ggv ${Simulation::Automate::PostProcLib::simtempl}-${Simulation::Automate::PostProcLib::anatempl}.ps &");
+system("${Simulation::Automate::PostProcLib::plotcommand} ${Simulation::Automate::PostProcLib::simtempl}-${Simulation::Automate::PostProcLib::anatempl}.ps &");
 }
 } # END of gnuplot_combined()
 #------------------------------------------------------------------------------
+sub parse_gnuplot_templ {
+my $synsimdataref=shift;
+my %synsimdata=%{$synsimdataref};
+
+  no strict;
+
+  foreach my $key (keys %synsimdata){
+    ($key=~/^\d*$/)&&next;
+    my $lcname=lc($key);
+    if($key=~/^_/) {
+      @{$lcname}=@{$synsimdata{$key}};
+    } else {
+      $$lcname=$synsimdata{$key};
+    }
+  }
+my $normvarval=$synsimdata{$normvar}[0];
+
+#plot templates can be either 
+#SIMPTYPE.PLOTTEMPL, stored under TEMPLATES or TEMPLATES/SYMTYPE
+#$dataset.PLOTTEMPL, stored next to $dataset.data
+my $plot_templ_file="../$datafilename$plottempl"; 
+#print "../$datafilename$plottempl\n"; 
+if( not -e $plot_templ_file) {
+  $plot_templ_file="../TEMPLATES/$simtempl$plottempl";
+  if( not -e $plot_templ_file) {
+    $plot_templ_file='';
+  }
+}
+#print " plot_templ_file $plot_templ_file\n";
+
+my $xcolentry='(\$_XCOL*1):';
+
+if(not exists $synsimdata{XCOL} and not exists $synsimdata{XVAR} and not exists $synsimdata{SWEEPVAR} and ($xcol && ($xcol!~/\d/))){
+$xcolentry='';
+}
+my $firstplotline=<<"ENDH";
+set terminal postscript landscape enhanced  color solid "Helvetica" 14
+set output "${simtempl}-${anatempl}.ps"
+
+$logscale
+
+#set xtics $xtics
+#set mxtics 2
+set grid xtics ytics mxtics mytics
+
+set key right top box 
+set key title "$legendtitle" 
+
+set title "$title" "Helvetica,18"
+set xlabel "$xlabel" "Helvetica,16"
+set ylabel "$ylabel" "Helvetica,16"
+
+ENDH
+
+my $plotlinetempl=q["\'$filename\' using _XCOLENTRY(\$_YCOL/_NORMVAR) title \"$legend\" with _PLOTSTYLE"];
+$plotlinetempl=~s/_XCOLENTRY/$xcolentry/;
+$plotlinetempl=~s/_NORMVAR/$normvarval/;
+$plotlinetempl=~s/_YCOL/$ycol/;
+$plotlinetempl=~s/_XCOL/$xcol/;
+$plotlinetempl=~s/_PLOTSTYLE/$plotstyle/;
+my $range='';
+  if($plot_templ_file) {
+    $firstplotline='';
+    open(PLOTTEMPL,"<$plot_templ_file");
+
+    while (<PLOTTEMPL>) {
+      /FILENAME/ && ($plotlinetempl=$_) && last;
+      s/OUTPUT/${simtempl}-${anatempl}/;
+      s/PLOTTITLE/$title/;
+      s/LEGENDTITLE/$legendtitle/;
+      s/XLABEL/$xlabel/;
+      s/YLABEL/$ylabel/;
+      s/XTICS/$xtics/;
+      s/YTICS/$ytics/;
+      s/LOGSCALE/$logscale/;
+      $firstplotline.=$_;
+    }
+    chomp($plotlinetempl);
+    $plotlinetempl=~s/\$/\\\$/g;
+    $plotlinetempl=~s/RESULTSFILENAME/\$filename/g;
+    $plotlinetempl=~s/FILENAME/\$filename/g;
+    $plotlinetempl=~s/XCOL/$xcol/;
+    $plotlinetempl=~s/YCOL/$ycol/;
+    $plotlinetempl=~s/NORMVAR/$normvarval/;
+    $plotlinetempl=~s/LEGENDENTRY/\$legend/;
+    $plotlinetempl=~s/LEGEND/\$legend/;
+    $plotlinetempl=~s/PLOTSTYLE/$plotstyle/;
+    $plotlinetempl=~s/^plot\s+//;
+    $plotlinetempl=~s/\'/\\\'/g;
+    $plotlinetempl=~s/\"/\\\"/g;
+    $plotlinetempl=~s/XSTART/$xstart/;
+    $plotlinetempl=~s/XSTOP/$xstop/;
+    $plotlinetempl=~s/YSTART/$ystart/;
+    $plotlinetempl=~s/YSTOP/$ystop/;
+
+
+( $plotlinetempl=~s/(\[[\d\.eE\-\+]*\:[\d\.eE\-\+]*\]\s+)//) && do {
+$range=$1;
+};
+    $plotlinetempl='"'.$plotlinetempl.'"';
+  }
+$range||='';
+
+  return [$firstplotline,$plotlinetempl,$range];
+
+} # END of parse_gnuplot_templ()
+#------------------------------------------------------------------------------
 sub copy_results {
 use Cwd;
 my $workingdir=cwd();
@@ -265,8 +486,17 @@
 #------------------------------------------------------------------------------
 sub create_legend {
 my $title=shift;
+
 my %make_nice=%{shift(@_)};
-my %title=split('-',$title);
+
+$title=~s/\-\-/\-\_MINUS_/g;
+(my $legendkey,my $legendvalue)=split('-',$title);
+$legendkey||=' ';
+$legendvalue||=' ';
+($legendkey=~/_MINUS_/)&&($legendkey=~s/_MINUS_/\-/g);
+($legendvalue=~/_MINUS_/)&&($legendvalue=~s/_MINUS_/\-/g);
+
+my %title= ($legendkey=>$legendvalue);
 
 my $legend='';
 my $legendtitle='';
@@ -281,12 +512,40 @@
 return [$legendtitle,$legend];
 }
 #------------------------------------------------------------------------------
+sub import_symbols { 
+  no strict;
+  foreach my $name (sort keys %Simulation::Automate::PostProcLib::simdata) {
+    ($name=~/^\d*$/) && next;
+    my $lcname=lc($name);
+    if($name=~/^_/) {
+      @{"Simulation::Automate::PostProcLib::$lcname"}=@{$Simulation::Automate::PostProcLib::simdata{$name}};
+      @{"Simulation::Automate::PostProcessors::$lcname"}=@{$Simulation::Automate::PostProcLib::simdata{$name}};
+      push @Simulation::Automate::PostProcLib::EXPORT,'@'.$lcname;
+    } else {
+      ${"Simulation::Automate::PostProcLib::$lcname"}=$Simulation::Automate::PostProcLib::simdata{$name};
+      ${"Simulation::Automate::PostProcessors::$lcname"}=$Simulation::Automate::PostProcLib::simdata{$name};
+      push @Simulation::Automate::PostProcLib::EXPORT,'$'.$lcname;
+    }
+  }
+}
+#------------------------------------------------------------------------------
 sub make_nice {
 my $varname=shift;
+if($varname=~/,/){
+  my @varnames=split(', ',$varname);
+  foreach my $varname (@varnames) {
 $varname=~s/^_//;
 $varname=~s/_/ /g;
 $varname=lc($varname);
 $varname=~s/^([a-z])/uc($1)/e;
+  }
+  $varname=join(', ',@varnames);
+} else {
+$varname=~s/^_//;
+$varname=~s/_/ /g;
+$varname=lc($varname);
+$varname=~s/^([a-z])/uc($1)/e;
+}
 return $varname;
 }
 #------------------------------------------------------------------------------
Only in Simulation-Automate-1.0.0/Automate: PreProcessors.pm
diff -r -b -B --ignore-all-space -u Simulation-Automate-0.9.7/Automate/Remote.pm Simulation-Automate-1.0.0/Automate/Remote.pm
--- Simulation-Automate-0.9.7/Automate/Remote.pm	2003-09-04 11:04:52.000000000 +0000
+++ Simulation-Automate-1.0.0/Automate/Remote.pm	2004-01-05 11:11:56.000000000 +0000
@@ -1,7 +1,7 @@
 package Simulation::Automate::Remote;
 
 use vars qw( $VERSION );
-$VERSION = "0.9.6";
+$VERSION = "1.0.0";
 
 #################################################################################
 #                                                                              	#
@@ -119,7 +119,8 @@
 #Simple check: create a file with the name of the localhost, and check for its existence over ssh
 my $nfstest="$homepath/$localsynsimpath/$rundir/$localhost";
 system("touch $nfstest");
-my $nonfs=`ssh $remotehost  perl -e 'if(-e $nfstest ){print "0"}else{print "1"}'`;
+#print STDERR qq(ssh $remotehost  perl -e \'if ( -e "$nfstest" ){print "0"}else{print "1"}\');die;
+my $nonfs=`ssh $remotehost  "perl -e 'if ( -e qq($nfstest) ){print 0}else{print 1}'"`;
 if($nonfs) {
 #first time, or at start of run
 #actually, the best way is to create synsim_remote.pl on the fly
@@ -129,7 +130,8 @@
 #at start of synsim run
 system("ssh $remotehost  perl $scriptname");
 #after synsim run, collect the data
-system("rsync -uva ${remotehost}::home/$user/$remotesynsimpath/$rundir/$simdir .");
+#system("rsync -uva ${remotehost}::home/$user/$remotesynsimpath/$rundir/$simdir .");
+system("scp -C -r ${remotehost}:/local/home/$user/$remotesynsimpath/$rundir/$simdir .");
 } else {
 # In case of NFS homedir, it's simpler:
 system("ssh $remotehost 'cd $homepath/$localsynsimpath/$rundir && ./synsim -p -f $datafile'");
@@ -174,15 +176,18 @@
 
 if (not -d "$rundir"){mkdir "$rundir" or die $!};
 chdir "$rundir";
-system("rsync -uva  ${localhost}::home/$user/$localsynsimpath/$rundir/SOURCES .");
-system("rsync -uva  ${localhost}::home/$user/$localsynsimpath/$rundir/TEMPLATES .");
-system("rsync -uva  ${localhost}::home/$user/$localsynsimpath/$rundir/synsim .");
-system("rsync -uva  ${localhost}::home/$user/$localsynsimpath/$rundir/$datafile .");
-
+#system("rsync -uva  ${localhost}::home/$user/$localsynsimpath/$rundir/SOURCES .");
+#system("rsync -uva  ${localhost}::home/$user/$localsynsimpath/$rundir/TEMPLATES .");
+#system("rsync -uva  ${localhost}::home/$user/$localsynsimpath/$rundir/synsim .");
+#system("rsync -uva  ${localhost}::home/$user/$localsynsimpath/$rundir/$datafile .");
+system('scp -r -C ${localhost}:$homepath/$user/$localsynsimpath/$rundir/SOURCES .");
+system('scp -r -C ${localhost}:$homepath/$user/$localsynsimpath/$rundir/TEMPLATES .");
+system('scp -r -C ${localhost}:$homepath/$user/$localsynsimpath/$rundir/synsim .");
+system('scp -r -C ${localhost}:$homepath/$user/$localsynsimpath/$rundir/$datafile .");
 #now run synsim
 system("./synsim -v -p -f $datafile");
 
-#to get the results back, we'll rsync from the other side
+#to get the results back, we'll scp from the other side
 
 ENDTEMPL
 }
diff -r -b -B --ignore-all-space -u Simulation-Automate-0.9.7/Automate.pm Simulation-Automate-1.0.0/Automate.pm
--- Simulation-Automate-0.9.7/Automate.pm	2003-09-19 16:03:20.000000000 +0000
+++ Simulation-Automate-1.0.0/Automate.pm	2004-01-05 11:11:56.000000000 +0000
@@ -1,7 +1,7 @@
 package Simulation::Automate;
 
 use vars qw( $VERSION );
-$VERSION = "0.9.7";
+$VERSION = "1.0.0";
 
 #################################################################################
 #                                                                              	#
@@ -22,10 +22,10 @@
 #
 
 
-use sigtrap qw(die untrapped normal-signals
-               stack-trace any error-signals); 
+use warnings;
 use strict;
 use Cwd;
+use Carp;
 use Exporter;
 use lib '.';
 use Simulation::Automate::Remote;
@@ -61,8 +61,8 @@
 $dataset=~s/\.data//;
 print STDERR "\nCreating Loops.pm...\n" if $verbose;
 
-my $dataref=&allow_multiple_sims($datafile);
-my $simref=&generate_loop_module($dataref,$dataset,\@flags);
+(my $dataref,my $groupedref)=&allow_multiple_sims($datafile);
+my $simref=&generate_loop_module($dataref,$groupedref,$dataset,\@flags);
 
 ################################################################################
 #
@@ -71,9 +71,13 @@
 ################################################################################
 
 &execute_loop($datafile,$dataset,$simref,\@flags) && do {
-unlink "Loops_$dataset.pm";
+#unlink "Loops_$dataset.pm";
 };
-print STDERR "\nFinished SynSim run for $dataset\n\n";
+if($dataset ne 'synsim'){
+print STDERR "\nFinished SynSim run for $dataset.data\n\n";
+} else {
+print STDERR "\nFinished SynSim run\n\n";
+}
 return 1;
 }
 #===============================================================================
@@ -107,11 +111,16 @@
 	(not -d 'TEMPLATES/SIMTYPES') && mkdir 'TEMPLATES/SIMTYPES';
 	(not -d 'TEMPLATES/DEVTYPES') && mkdir 'TEMPLATES/DEVTYPES';
 	(not -d 'SOURCES') && mkdir 'SOURCES';
+	(not -d 'PLUGINS') && mkdir 'PLUGINS';
 	die "An empty directory structure has been created\n";
       }
       if(/-h|-\?/) { 
 my $script=$0;
 $script=~s/.*\///;
+
+# -f flag now optional
+# -f [filename]: 'file input'. Expects a file containing info about simulation and device type.
+
 die <<"HELP";
 
 The script must be executed in a subdirectory of the directory
@@ -119,15 +128,16 @@
 This directory must contain at least a TEMPLATES/SIMTYPE subdir 
 with the simulation templates, and a data file. See documentation for more information.
 
-syntax: ./$script [-h -i -p -v -w -N -f datafile]
+syntax: ./$script [-h -D -i -p -P -v -w -N datafile]
 
 Possible switches:
 
 none: defaults to -f $datafile
- -f [filename]: 'file input'. Expects a file containing info about simulation and device type.
- -i : interactive. Creates a plot on the screen after every iteration. Implies -p -v
- -p : plot.  
+ -D : Create an empty SynSim directory structure in the current directory
  -v : 'verbose'. Sends simulator output to STDOUT, otherwise to simlog file
+ -p : plot. This creates the plot, but does not display it
+ -i : interactive. Creates a plot on the screen after every iteration. Implies -p -v
+ -P : Plot. This displays plots created with -p
  -w : 'warnings'. Show warnings for undefined variables.
  -N : 'No simulations'. Does only postprocessing
  -h, -? : this help
@@ -162,16 +172,21 @@
 }
 if($justplot){
 #convenience function to plot results
-chomp(my $simtype=`egrep ^SIMTYPE $datafile`);
-$simtype=~s/^SIMTYPE\s*:\s*//;
+chomp(my $simtype=`egrep '^SIM(TYPE|NAME|ULATION|TEMPL)|^\ *TEMPLATE' $datafile`);
+$simtype=~s/^SIM(TYPE|NAME|ULATION)|^\s*TEMPLATE\s*:\s*//;
 $simtype=~s/\s*$//;
-chomp(my $anatype=`egrep ^ANALYSIS_TEMPLATE $datafile`);
-$anatype=~s/^ANALYSIS_TEMPLATE\s*:\s*//;
+$simtype=~s/\..*$//;
+chomp(my $anatype=`egrep '^ANA(LYSIS)*_*(TEMPL)*(ATE)*' $datafile`);
+$anatype=~s/^ANA(LYSIS)*_*(TEMPL)*(ATE)*\s*:\s*//;
 $anatype=~s/\s*$//;
 $datafile=~s/\.data//;
 
 chdir "${simtype}-$datafile";
-system("ggv ${simtype}-$anatype.ps");
+  my $gv='/usr/bin/ggv';
+  if((not -e '/usr/bin/ggv') and ( -e '/usr/X11R6/bin/gv')) {
+  $gv='/usr/X11R6/bin/gv';
+  }
+system("$gv ${simtype}-$anatype.ps");
 die "Done\n";
 }
 return [$batch,$interactive,$nosims,$plot,$verbose,$warn];
@@ -185,6 +200,9 @@
 
 sub generate_loop_module {
 my $specificref=shift; #this is the reference to %specific, the hash of arrays of data for each sim
+my $groupedref=shift;
+my %grouped=%$groupedref;
+
 my $dataset=shift;
 my $flagsref=shift;
 my ($batch,$interactive,$nosims,$plot,$verbose,$warn)=@{$flagsref};
@@ -230,12 +248,9 @@
 my $title=$data{$sim}{TITLE};
 delete $data{$sim}{TITLE};
 
-#experimental
 my $nruns=(exists $data{$sim}{NRUNS})?$data{$sim}{NRUNS}:1;
 if($nruns>1) {
 $data{$sim}{__NRUNS}=join(',',(1..$nruns));
-#also, make sure the SWEEPVAR list is comma-separated
-#$data{$sim}{$data{$sim}{SWEEPVAR}}=~s/;/,/g;
 }
 push @sims,$sim;
 print MOD &strip(<<"ENDSUBHEAD");
@@ -243,7 +258,8 @@
 *use lib '..','../..';
 *#use Simulation::Automate::Main;
 *use Simulation::Automate;
-*use Simulation::Automate::PostProcessors;
+*#use Simulation::Automate::PostProcessors;
+*use Simulation::Automate::PostProcLib;
 *
 *sub execute_${sim}_loop {
 *my \$dataset=shift;
@@ -255,27 +271,47 @@
 *my \%last=();
 *my \%sweepeddata=();
 *my \$v=$verbose;
+*my \$leaveloop=0;
 
 ENDSUBHEAD
 
-if($data{$sim}{'PREPROCESSOR'}) {
-print MOD &strip('
-*my $preprocref=\&Simulation::Automate::PostProcessors::'.$data{$sim}{'PREPROCESSOR'}.';
-');
-} else {
-print MOD &strip('
-*my $preprocref;
-');
-}
+#if($data{$sim}{'PREPROCESSOR'}) {
+#print MOD &strip('
+#*my $preprocref=\&Simulation::Automate::PostProcessors::'.$data{$sim}{'PREPROCESSOR'}.';
+#');
+#} else {
+#print MOD &strip('
+#*my $preprocref;
+#');
+#}
 
 # TITLE is treated separately
 print MOD &strip(
 "*my \$TITLE = '$title';\n"
 );
+
+ foreach my $par (sort keys %{$data{$sim}}) {
+$par!~/^\_/ && next;
+  #Here as good as anywhere else
+  if ((exists $data{$sim}{XVAR} and $par eq $data{$sim}{XVAR})  or (exists $data{$sim}{SWEEPVAR} and $par eq  $data{$sim}{SWEEPVAR})) {
+    #the sweep variable, make sure it's ; not ,
+    $data{$sim}{$par}=~s/,/;/g; # a bit rough, comments at end get it as well
+    #make sure grouped variables are treated as well
+    if (exists $grouped{$par}) {
+      my $leader=$grouped{$par};
+      foreach my $gpar (sort keys %grouped) {
+	if( $grouped{$gpar} eq $leader) {
+	  $data{$sim}{$gpar}=~s/,/;/g;
+	  delete  $grouped{$gpar};
+   }
+   }
+ }
+}
+}
 # define vars
  foreach my $par (sort keys %{$data{$sim}}) {
 if ($data{$sim}{$par}!~/,/) { # if just one item
-#WV21052003 support for "for..to..step.."-style lists
+     # support for "for..to..step.."-style lists
 $data{$sim}{$par}=&expand_list($data{$sim}{$par});
 
 $data{$sim}{$par}=~s/^\'//;
@@ -366,10 +403,33 @@
 foreach my $par (sort keys %{$data{$sim}}) {
 
   if ($data{$sim}{$par}=~/,/) { # if more than one item
-#WV21052003 support for "for to step"-style lists
+    # support for "for to step"-style lists
 $data{$sim}{$par}=&expand_list($data{$sim}{$par});
 my $parlist=$data{$sim}{$par};
 $parlist=~s/,/ /g;
+    #support for "grouped" parameters
+    if(exists $grouped{$par}) {
+      if($grouped{$par} eq $par){ # the "leader" of the group
+	my $leader=$par;
+	foreach my $var (sort keys %grouped) {
+	  if($grouped{$var} eq $leader){
+	    my $varlist=$data{$sim}{$var};
+	    $varlist=~s/,/ /g;
+	    print MOD &strip(
+			     "*my \@${var}list = qw($varlist);
+*\$last{$var}=\$${var}list[\@${var}list-1];
+");
+	  }
+	}
+	print MOD &strip("*foreach my \$${par} (\@${par}list) {\n");
+	foreach my $var (sort keys %grouped) {
+	  ($var eq $par) && next;
+	  if($grouped{$var} eq $leader){
+	    print MOD &strip("*my \$${var}=shift(\@${var}list);\n");
+	  }
+	}	
+      } 
+    } else {
     print MOD &strip(
 		     "*my \@${par}list = qw($parlist);
 *\$last{$par}=\$${par}list[\@${par}list-1];
@@ -377,6 +437,7 @@
 		    );
   } 
 }
+}
 print MOD &strip(
 "*\$i++;
 *open(RES,\">\$dirname\/${sim}_C\$i.res\")|| do {print STDERR \"Can\'t open \$dirname\/${sim}_\$i.res\" if \$v;};
@@ -389,16 +450,18 @@
 *	print RES "# Parameters for simulation run $i:\n";
 ');
 
+my $simtempl=$data{$sim}{SIMTYPE}||$data{$sim}{SIMNAME}||$data{$sim}{SIMULATION}||$data{$sim}{TEMPLATE}||$data{$sim}{SIMTEMPL};
+#$simtempl=~s/\.\w+$//;
 
-my $simtempl=$data{$sim}{SIMTYPE};
-my $anatempl=$data{$sim}{ANALYSIS_TEMPLATE}||'NoAnalysisDefined';
+my $anatempl=$data{$sim}{ANALYSIS_TEMPLATE}||$data{$sim}{ANALYSIS}||$data{$sim}{ANATEMPL}||$data{$sim}{ANALYSIS_TEMPL}||$data{$sim}{ANA_TEMPLATE}||'None';#'NoAnalysisDefined';
 my $subref=$anatempl;
 
 print MOD &strip('
 *my $resfilename="'.$sim.'-'.$anatempl.'";
+*$data{RESHEADER}=$resheader;
 ');
-foreach my $par (sort keys %{$data{$sim}}) {
 
+foreach my $par (sort keys %{$data{$sim}}) {
   if ($data{$sim}{$par}=~/,/) { # if more than one item
     print MOD &strip(
 		     "*\$data{$par} = [\$$par];
@@ -410,49 +473,67 @@
   }
 }
 
-#WV21042003: old, sweep loops internal
-print MOD &strip(
-"* close RES;
-*\$resfilename.='.res';
-*#NEW01072003#rename \"\$dirname\/${sim}_C\$i.res\",\"\$dirname\/\$resfilename\";
-*my \$dataref = [\$nsims,\\\%data];
-*\$returnvalue=&main(\$dataset,\$i,\$dataref,\$resfilename,\$flagsref);
-*
-");
-
-##WV21042003: new, sweep loops external
+##WV21042003: old, sweep loops internal
 #print MOD &strip(
 #"* close RES;
+#*\$resfilename.='.res';
+#*#NEW01072003#rename \"\$dirname\/${sim}_C\$i.res\",\"\$dirname\/\$resfilename\";
 #*my \$dataref = [\$nsims,\\\%data];
-#*my \$nsims=&pre_run(\$dataset,\$i,\$dataref,\$flagsref);
-#*foreach my \$simn (1..\$nsims) {
-#*\$returnvalue=&run(\$nsims,\$simn);
-#*}
-#*\$returnvalue=&post_run(\$dataset,\$i,\$dataref,\$flagsref);
-#*
+#*\$returnvalue=&main(\$dataset,\$i,\$dataref,\$resfilename,\$flagsref);
 #*
 #");
 
+#WV21042003: new, sweep loops external
+
+#The idea is to evaluate a condition inside the loop, after very sim
+#If the condition is satisfied, skip the next 
+
+print MOD &strip(
+"* close RES;
+*my \$dataref = [\$nsims,\\\%data];
+*#my \$nsims=&pre_run(\$dataset,\$i,\$dataref,\$flagsref);
+*\$nsims=&pre_run(\$dataset,\$i,\$dataref,\$flagsref);
+*my \$dataref_postproc = [\$nsims,\\\%data,\\\%sweepeddata,\\\%last];
+*foreach my \$simn (1..\$nsims) {
+*\$leaveloop && last;
+*\$returnvalue=&run(\$nsims,\$simn);
+*#print STDERR \"RET:\$returnvalue=\$nsims,\$simn\\n\";
+*
+*#Call postprocessor inside loop to see if we can leave the loop early
+*#chdir \$dirname;
+*#print \"SUBREF:$subref\\n\";
+*#\$leaveloop=&Simulation::Automate::PostProcessors::$subref(\$dataset,\$i,\$dataref_postproc,\$flagsref,[\$returnvalue],\$preprocref,2);
+*#chdir '..';
+*#print \"LEAVE: \$leaveloop\\n\";
+*}
+*\$returnvalue=&post_run();
+*
+");
+
 
 print MOD &strip(<<"ENDPP");
 *chdir \$dirname;
 *my \$dataref1 = [\$nsims,\\\%data,\\\%sweepeddata,\\\%last];
-*&Simulation::Automate::PostProcessors::$subref(\$dataset,\$i,\$dataref1,\$flagsref,\$returnvalue,\$preprocref);
+*#&Simulation::Automate::PostProcessors::$subref(\$dataset,\$i,\$dataref1,\$flagsref,\$returnvalue,\$preprocref);
+*&prepare(\$dataset,\$i,\$dataref1,\$flagsref,\$returnvalue);
 *chdir '..';
 ENDPP
 
 foreach my $par (reverse sort keys %{$data{$sim}}) {
   if ($data{$sim}{$par}=~/,/) {
+    if( not exists $grouped{$par} or (exists $grouped{$par} and ($grouped{$par} eq $par))) {
     print MOD &strip(
 		     "*} #END of $par\n"
 		    );
   }
 }
+}
 
 print MOD &strip(<<"ENDPP");
 *chdir \$dirname;
 *my \$dataref2 = [\$nsims,\\\%data,\\\%sweepeddata,\\\%last];
-*&Simulation::Automate::PostProcessors::$subref(\$dataset,\$i,\$dataref2,\$flagsref,1);
+*#&Simulation::Automate::PostProcessors::$subref(\$dataset,\$i,\$dataref2,\$flagsref,1);
+*&prepare(\$dataset,\$i,\$dataref2,\$flagsref,1);
 *chdir '..';
 ENDPP
 
@@ -484,7 +565,7 @@
 # This is %data, which is returned to $dataref in  generate_loop_module()
 # 
 sub fill_data_hash_multi {
-my $dataref=shift;
+my $dataref=shift; # reference to %specific
 my %data=();
 my %multisimdata=%$dataref;
 foreach my $sim (keys %multisimdata) {
@@ -507,8 +588,6 @@
 my $line=$_;
 ($line=~s/^([A-Z0-9_]+)?\s*\:\s*//)&&($line[0]=$1);
 $line[1]=$line;
-##strip leading _
-#$line[0]=~s/^\s*_//;
 #strip trailing spaces
 $line[1]=~s/\s+$//;
 $data{$sim}{$line[0]}=$line[1];
@@ -533,6 +611,7 @@
 my $simpatt='NOPATTERN';
 my @common=();
 my %specific=();
+my %grouped=();
 my $simtype='NOKEY';
 my $skip=0;
 open(DATA,"<$datafile")|| die "Can't open $datafile\n";
@@ -563,23 +642,45 @@
 #print STDERR "$_\n";
 s/(\#.*)//;
 s/[;,]\s*$//; # be tolerant
-if(/SIMTYPE\s*:/) {
+if(/SIM(TYPE|NAME|ULATION|TEMPL)|\bTEMPLATE\s*:/) {
 my $sims=$_;
+s/TEMPLATE/SIMULATION/;
+s/\.\w+$//;
 (my $par,$simpatt)=split(/\s*:\s*/,$sims);
 $simpatt=~s/\s*\,\s*/|/g;
 $simpatt=~s/\s+//g;
 @sims=split(/\|/,$simpatt);
+my $ext='';
+foreach my $sim (@sims){
+$sim=~s/(\.\w+)$//;
+$ext=$1;
+};
+if($ext && $ext=~/^\./){
+push @common,"TEMPL: $ext\n";
+}
+$simpatt=join('|',@sims);
 $simpatt='('.$simpatt.')';
 } elsif(/$simpatt/) {
 $skip=0;
 $simtype=$1;
+#$simtype=~s/\.\w+$//;
 $simpart=1
 } elsif(/^\s*[a-zA-Z]/&&!/:/) {
 $simpart=0;
 $skip=1;
 print STDERR "$_: Not present in simlist. Skipping data.\n";
 }
-
+/^\s*GROUP\s*:\s*([\_A-Z0-9\,\;\s]+)$/ && do {
+my $groupline=$1;
+my @grouped=split(/\s*\;\s*/,$groupline);
+foreach my $group (@grouped){
+my @groupline=split(/\s*\,\s*/,$group);
+foreach my $item (@groupline){
+$grouped{$item}=$groupline[0];
+}
+}
+next;
+};
 if($simpart) {
 push @{$specific{$simtype}},$_;
 } elsif(!$skip) {
@@ -595,7 +696,7 @@
 push @{$specific{$sim}},@common;
 }
 
-return \%specific;
+return (\%specific,\%grouped);
 } #END of allow_multiple_sims
 #-------------------------------------------------------------------------------
 #
@@ -608,20 +709,26 @@
 my @list=split(/\s*$sep\s*/,$list);
 if(@list==3 && $list!~/[a-zA-Z]/) { # 
 if(
-(abs($list[0])<abs($list[1]))&&(abs($list[2])<abs($list[1]-$list[0]))
-) { #it's a for-to-step list, expand it
+(
+($list[0]<$list[1] && $list[2]>0)||($list[0]>$list[1] && $list[2]<0)
+) && (
+abs($list[2])<abs($list[1]-$list[0])
+)
+) {
 my $start=$list[0];
 my $stop=$list[1];
 my $step=$list[2];
 $list="$start";
 my $i=$start;
-#while($i*(abs($step)/$step)<$stop*(abs($step)/$step)){
-while(("$i" ne "$stop") && (abs($i)-abs($stop))<=0) { #yes, strange, but Perl says 0.9>0.9 is true!
+while(("$i" ne "$stop")&&((($stop>=0)&&($i<$stop))||(($stop<0)&&($i>$stop)))) { #yes, strange, but Perl says 0.9>0.9 is true!
 $i+=$step;
 $list.="$sep$i";
 }
+#print "LIST: $list\n";
+#die;
 }
 }
+
 return $list;
 } # END of expand_list
 #===============================================================================
@@ -641,9 +748,20 @@
 my $verbose=$flags[4];
 
 foreach my $sim (sort keys %{$simref}) {
+my $commandline=${$simref}{$sim}->{COMMAND};
+
+$commandline && do {
+$commandline=~s/inputfile//i;
+$commandline=~s/outputfile//i;
+$commandline=~s/\s\-+\w+//g;
+$commandline=~s/^\s+//;
+$commandline=~s/\s+$//;
+};
+my @maybe_files=($commandline)?split(/\s+/,$commandline):();
+
 # extension for template files
-my $templ=${$simref}{$sim}->{TEMPL}||'.templ';
-my $dev=${$simref}{$sim}->{DEVTYPE}||'';
+my $templ=${$simref}{$sim}->{TEMPLEXT}||${$simref}{$sim}->{TEMPL}||'.templ';
+my $dev=${$simref}{$sim}->{DEVTYPE}||${$simref}{$sim}->{DEVICE}||'';
 
 my $dirname= "${sim}-$dataset";
 
@@ -666,17 +784,18 @@
 }
 }
 
-  if (not -e "TEMPLATES/SIMTYPES/$sim$templ" ) {
-print STDERR "No templates for simulation $sim. Skipped.\n" if $verbose;
+  if (not -e "TEMPLATES/SIMTYPES/$sim$templ" and not -e "TEMPLATES/$sim$templ" ) {
+   
+print STDERR "No templates for simulation $sim. Skipped.\n";# if $verbose; #always warn!
 next;
-} else {
 
+} else {
+#if the template in under TEMPLATES, make a simlink to TEMPLATES/SIMTYPES
+ if (-e "TEMPLATES/$sim$templ" and not -l "TEMPLATES/SIMTYPES/$sim$templ" ) {
+      system("cd TEMPLATES/SIMTYPES && ln -s ../$sim$templ .");
+    } 
 mkdir $dirname, 0755;
-#WV1710: new organisation, allow both devices & simulations
-#old:
-#system("cp TEMPLATES/SIMTYPES/$sim.* $dirname");
-#system("cp TEMPLATES/DEVTYPES/$sim.* $dirname");
-#new:
+
 if (-e "TEMPLATES/SIMTYPES/$sim$templ") {
 system("cp TEMPLATES/SIMTYPES/$sim$templ $dirname");
 } else {
@@ -694,6 +813,11 @@
   if(<SOURCES/$sim*>){
 system("cp SOURCES/$sim* $dirname");
 }
+  foreach my $maybe_file(@maybe_files){
+    if(-e "SOURCES/$maybe_file" and not -e "$dirname/$maybe_file"){
+      system("cp SOURCES/$maybe_file $dirname/$maybe_file");
+    }
+  }
 } 
 }
 print STDERR "#" x 80,"\n" if $verbose;
@@ -722,149 +846,18 @@
 ##################################################################################
 my $simpid=undef; 
 
-sub main {
-
-use Cwd;
-#&main($dataset,$i,$dataref,$resfilename,$flagsref);
-my $dataset=shift; 
-my $count=shift;
-my $dataref=shift;
-my $resfile=shift;
-my $flagsref=shift;
-
-my ($batch,$interactive,$nosims,$plot,$verbose,$warn)=@{$flagsref};
-
-(my $nsims, my $simdataref)=@{$dataref};
-
-print STDERR '#',"-" x 79, "\n" if $verbose;## Simulation run $count\n";
-
-my %simdata=%{$simdataref};
-
-my @results=();
-my $command=$simdata{COMMAND}||'perl inputfile outputfile'; 
-
-my $output_filter_pattern=$simdata{OUTPUT_FILTER_PATTERN}|| '.*';
-my $simtype=$simdata{SIMTYPE}||'';
-my $dirname= "${simtype}-$dataset";
-
-my $devtype=$simdata{DEVTYPE}||'';
-my $simtitle=$simdata{TITLE};
-my @sweepvarnames=();
-foreach my $key (keys %simdata) {
-($key!~/^_/) && next;
-($simtitle=~/$key/) && do {
-$simtitle=~s/$key/$key:$simdata{$key}->[0]/;
-};
-my $ndata=@{$simdata{$key}};
-if($ndata>1) {
-push @sweepvarnames,$key;
-  }
-}
-my $title="#$simtitle\n"||"#$devtype $simtype simulation\n";
-my $ext=$simdata{TEMPL}||'.templ';
-my $extin=$simdata{EXT}||'.pl';
-my $workingdir =cwd();
-chdir  "$workingdir/$dirname";
-
-## INPUT FILE CREATION
-
-foreach my $simn (1..$nsims) {
-  if($nsims==1){$simn=''} else {
-    print STDERR "# Subrun $simn of $nsims: " if $verbose;
-    foreach my $sweepvarname(@sweepvarnames){
-      print STDERR " $sweepvarname = ",$simdata{$sweepvarname}->[$simn-1] if $verbose;
-    }
-    print STDERR " \n" if $verbose;
-  }
-  my $inputfile= "${simtype}_${simn}$extin";
-  my $outputfile= "${simtype}_C${count}_${simn}.out";
-  my $commandline=$command;
-  $commandline=~s/inputfile/$inputfile/ig;
-  $commandline=~s/outputfile/$outputfile/ig;
-  
-  open (NEW, ">$inputfile");
-  print NEW ("$title");
-
-  foreach my $type ($devtype,$simtype) {
-    if($type) {
-      my $nsim=($simn eq '')?0:$simn;
-      &gen_sim_script ($nsim-1,"$simtype$ext",\%simdata,\*NEW,$dataset,$warn);
-      print NEW ("\n");
-    }
-  } # device and simulation templates
-  close (NEW);
-  
-  if($nosims==0) {
-    if($verbose) {
-      if (!defined($simpid = fork())) {
-	# fork returned undef, so failed
-	die "cannot fork: $!";
-      } elsif ($simpid == 0) {
-	# fork returned 0, so this branch is the child
-	exec("$commandline");
-	# if the exec fails, fall through to the next statement
-	die "can't exec $commandline : $!";
-      } else { 
-	# fork returned neither 0 nor undef, 
-	# so this branch is the parent
-	waitpid($simpid, 0);
-      } 
-      #system("$commandline");
-    } else { # not verbose
-      print STDERR "\n" if $verbose;
-      #      print STDERR grep /$output_filter_pattern/,`$commandline > simlog 2>&1`;
-      #or, with a pipe:
-      $simpid = open(SIM, "$commandline 2>&1 |") || die "can't fork: $!"; 
-      open(LOG,">simlog");
-      while (<SIM>) {
-	print LOG;
-	/$output_filter_pattern/ && do {
-	  print STDERR;# if $verbose;
-	};
-      } # while simulation is running
-      close LOG;
-      my $ppid=getpgrp($simpid);
-      if(not $ppid) {
-	close SIM || die "Trouble with $commandline: $! $?";
-      }
-      print STDERR "\n" if $verbose;
-    } #verbose or not
-# } # if simulations not disabled
-
-  if($nsims>1) {
-    #Postprocessing
-    &egrep($output_filter_pattern,"${simtype}_C${count}_${simn}.out",'>>',"${simtype}_C${count}_.out");
-  }
-  } # if simulations not disabled
-  my $i=($nsims>1)?$simn-1:0;
-  open(RES,"<${simtype}_C${count}_${simn}.out");
-  $results[$i]=<RES>;
-  my $another=<RES>; # This takes the next line, if any,
-  if($another) { # and if there is one, it assigns the filename to $results[$i]
-    $results[$i]="${simtype}_C${count}_${simn}.out";
-  }
-  close RES;
-} # nsims 
-
-#Postprocessing after sweep
-#if($nosims==0) {
-&egrep($output_filter_pattern, "${simtype}_C${count}_.out", '>>', "${simtype}_C$count.res");
-#NEW01072003#&egrep($output_filter_pattern, "${simtype}_C${count}_.out", '>>', $resfile);
-#}
-chdir "$workingdir";
 
-return \@results; # PostProcessors are only called after &main() exits.
-} #END of main()
 
 #========================================================================================
 #  NEW IMPLEMENTATION TO ALLOW POSTPROCESSING AFTER EVERY ELEMENT IN SWEEP
 #========================================================================================
 my @results=();
+my @sweepvarnames=();
 my %simdata=();
 my $simtype='NO_SIMTYPE';
 my $dataset='NO_DATASET';
 my $count=0;
-my ($batch,$interactive,$nosims,$plot,$verbose,$warn);
+my $batch; my $interactive; my $nosims; my $plot; my $verbose; my $warn;
 my $output_filter_pattern= '.*';
 my $command='perl inputfile outputfile'; 
 my $dirname= 'NO_DIRNAME';
@@ -875,61 +868,78 @@
 my $extin='.pl';
 my $workingdir = 'NO_WORKINGDIR';
 #------------------------------------------------------------------------------
-#&main(\$dataset,\$i,\$dataref,\$flagsref);
-#&pre_run(\$dataset,\$i,\$dataref,\$flagsref);
-#&run(\$dataset,\$i,\$dataref,\$flagsref);
-#&post_run(\$dataset,\$i,\$dataref,\$flagsref);
 
 sub pre_run {
-
-use Cwd;
-
+#called as:&pre_run(\$dataset,\$i,\$dataref,\$flagsref);
 $dataset=shift; 
 $count=shift;
 my $dataref=shift;
 my $flagsref=shift;
-($batch,$interactive,$nosims,$plot,$verbose,$warn)=@{$flagsref};
 
+use Cwd;
+
+#extract flags from flagsref
+($batch,$interactive,$nosims,$plot,$verbose,$warn)=@{$flagsref};
+#extract number of sims and ref to simdata from dataref
 (my $nsims, my $simdataref)=@{$dataref};
+#put simdata in a hash
+%simdata=%{$simdataref};
 
-print STDERR '#',"-" x 79, "\n" if $verbose;## Simulation run $count\n";
+print STDERR '#',"-" x 79, "\n" if $verbose;
 
-%simdata=%{$simdataref};
-#my @results=();
 $command=$simdata{COMMAND}||'perl inputfile outputfile'; 
-
 $output_filter_pattern=$simdata{OUTPUT_FILTER_PATTERN}|| '.*';
-$simtype=$simdata{SIMTYPE}||'';
+$simtype=$simdata{SIMTYPE}||$simdata{SIMNAME}||$simdata{SIMULATION}||$simdata{TEMPLATE}||$simdata{SIMTEMPL}||'';
+#$simtype=~s/\.\w+$//;
  $dirname= "${simtype}-$dataset";
- $devtype=$simdata{DEVTYPE}||'';
+$devtype=$simdata{DEVTYPE}||$simdata{DEVICE}||$simdata{DEVTEMPL}||'';
  $simtitle=$simdata{TITLE};
+@sweepvarnames=();
 foreach my $key (keys %simdata) {
 ($key!~/^_/) && next;
 ($simtitle=~/$key/) && do {
 $simtitle=~s/$key/$key:$simdata{$key}/;
 };
+my $ndata=@{$simdata{$key}};
+if($ndata>1) {
+push @sweepvarnames,$key;
+  }
 }
  $title="#$simtitle\n"||"#$devtype $simtype simulation\n";
- $ext=$simdata{TEMPL}||'.templ';
+$ext=$simdata{TEMPLEXT}||$simdata{TEMPL}||'.templ';
  $extin=$simdata{EXT}||'.pl';
  $workingdir =cwd();
 chdir  "$workingdir/$dirname";
 return $nsims;
 } #END of pre_run()
 #------------------------------------------------------------------------------
-sub run {
 
+sub run {
+#called as:&run(\$nsims,\$simn);
 my $nsims=shift;
 my $simn=shift;
 
-#use Cwd;
-#my ($nsims, my $simdataref)=@{$dataref};
-
 ## INPUT FILE CREATION
 
-#foreach my $simn (1..$nsims) {
   if($nsims==1){$simn=''} else {
-    print STDERR "# Subrun $simn of $nsims \n" if $verbose;
+#  print STDERR "# Subrun $simn of $nsims \n" if $verbose;
+   if($simn==1){
+print STDERR "# Sweep $nsims values for " if $verbose;
+    foreach my $sweepvarname(@sweepvarnames){
+      print STDERR "$sweepvarname " if $verbose;
+    }
+  print STDERR ":\n" if $verbose;
+    }
+    foreach my $sweepvarname(@sweepvarnames){
+      print STDERR $simdata{$sweepvarname}->[$simn-1],' ' if $verbose;
+#      print STDERR " $sweepvarname = ",$simdata{$sweepvarname}->[$simn-1] if $verbose;
+    }
+print STDERR " \n" if $verbose;
+
+ # foreach my $sweepvarname(@sweepvarnames){
+  #  print STDERR " $sweepvarname = ",$simdata{$sweepvarname}->[$simn-1] if $verbose;
+  #}
+#  
   }
   my $inputfile= "${simtype}_${simn}$extin";
   my $outputfile= "${simtype}_C${count}_${simn}.out";
@@ -938,13 +948,11 @@
   $commandline=~s/outputfile/$outputfile/ig;
   
   open (NEW, ">$inputfile");
-  print NEW ("$title");
 
   foreach my $type ($devtype,$simtype) {
     if($type) {
       my $nsim=($simn eq '')?0:$simn;
       &gen_sim_script ($nsim-1,"$simtype$ext",\%simdata,\*NEW,$dataset,$warn);
-      print NEW ("\n");
     }
   } # device and simulation templates
   close (NEW);
@@ -964,11 +972,8 @@
 	# so this branch is the parent
 	waitpid($simpid, 0);
       } 
-      # system("$commandline");
     } else { # not verbose
       print STDERR "\n" if $verbose;
-      #      print STDERR grep /$output_filter_pattern/,`$commandline > simlog 2>&1`;
-      #or, with a pipe:
       $simpid = open(SIM, "$commandline 2>&1 |") || die "can't fork: $!"; 
       open(LOG,">simlog");
       while (<SIM>) {
@@ -984,7 +989,7 @@
       }
       print STDERR "\n" if $verbose;
     } #verbose or not
-#  } # if simulations not disabled
+
   if($nsims>1) {
     #Postprocessing
     &egrep($output_filter_pattern,"${simtype}_C${count}_${simn}.out",'>>',"${simtype}_C${count}_.out");
@@ -998,16 +1003,23 @@
     $results[$i]="${simtype}_C${count}_${simn}.out";
   }
   close RES;
-#} # nsims 
+
 #no need to return @results, it's a package global now. Maybe return $results[$i], makes more sense.
-#return \@results; # PostProcessors are only called after &main() exits.
-return $results[$i]; # PostProcessors are only called after &main() exits.
+my $result= $results[$i];
+chomp $result;
+return $result; # PostProcessors are only called after &main() exits.
 } # END of run()
 #------------------------------------------------------------------------------
 sub post_run {
+#called as:&post_run();
   if($nosims==0){
 #Postprocessing after sweep
 &egrep($output_filter_pattern, "${simtype}_C${count}_.out", '>>', "${simtype}_C$count.res");
+if(  $results[0]=~/${simtype}_C\d+.*\.out/) {
+open(RES,"${simtype}_C$count.res");
+@results=<RES>;
+close RES;
+}
 }
 chdir "$workingdir";
 
@@ -1041,7 +1053,6 @@
 my %exprdata=();
 my %keywords=();
 foreach my $key ( sort keys %simdata) {
-#  ($key!~/^_/) && next;
 #make sure substitutions happen in keyword values too
   if ($key!~/^_/ ) {
     if( $simdata{$key}=~/^_/) {
@@ -1143,16 +1149,23 @@
 
 # Create simulation directory etc.
 sub setup {
-  use File::Copy;
+
 my $HOME=$ENV{HOME};
 print "Local SinSym directory? [$HOME/SynSim]:";
 my $synsimroot=<STDIN>;
 chomp $synsimroot;
 if(not $synsimroot){$synsimroot="$HOME/SynSim"}
+if($synsimroot!~/^\//) {
+print "The directory $synsimroot will be created in $HOME\n";
+$synsimroot="$HOME/$synsimroot"
+}
+
   if(not -d "$synsimroot"){
 mkdir "$synsimroot", 0755;
   }
-print "Simulation project name? [SynSimProject]:";
+
+
+print "Simulation project directory? [SynSimProject]:";
 my $project=<STDIN>;
 chomp $project;
 if(not $project){$project='SynSimProject'}
@@ -1166,10 +1179,14 @@
 mkdir "$synsimroot/$project/TEMPLATES/SIMTYPES", 0755;
   if(-d "eg"){
     if(-e "eg/synsim"){
-copy("eg/synsim","$synsimroot/$project/synsim");
+system("cp eg/synsim $synsimroot/$project/synsim");
 }
     if(-e "eg/synsim.data"){
-copy("eg/synsim.data","$synsimroot/$project/synsim.data");
+system("cp eg/synsim.data $synsimroot/$project/synsim.data");
+}
+
+    if(-e "eg/TEMPLATES/test.templ"){
+system("cp eg/TEMPLATES/test.templ $synsimroot/$project/TEMPLATES/");
 }
   }
 
@@ -1183,7 +1200,7 @@
 sub localinstall {
 my $full=shift||1;
 my $synsimroot=shift||'';
-  use File::Copy;
+
 my $HOME=$ENV{HOME};
 if(not $synsimroot) {
 print "Local SinSym directory? [$HOME/SynSim]:";
@@ -1207,17 +1224,17 @@
   if(-d "Automate") {  
 foreach my $module (qw(PostProcessors Dictionary)) {
 if( -e "Automate/$module.pm"){
-copy("Automate/$module.pm", "$synsimroot/Simulation/Automate/$module.pm");
+system("cp Automate/$module.pm $synsimroot/Simulation/Automate/$module.pm");
 }
 }
 if($full) {
   foreach my $module (qw(Remote PostProcLib Analysis)){
 if( -e "Automate/$module.pm"){
-copy("Automate/$module.pm", "$synsimroot/Simulation/Automate/$module.pm");
+system("cp Automate/$module.pm $synsimroot/Simulation/Automate/$module.pm");
 }
 }
 if( -e "Automate.pm"){
-copy("Automate.pm", "$synsimroot/Simulation/Automate.pm");
+system("cp Automate.pm $synsimroot/Simulation/Automate.pm");
 }
 } # if full local install
 } # if directory Automate exists in current dir. 
@@ -1244,19 +1261,13 @@
 
 =head1 REQUIREMENTS
 
-=over
-
-=item *
-
-a unix-like system
+=over 4
 
-=item *
-
-perl 5
+=item * a unix-like system
 
-=item *
+=item * perl 5
 
-gnuplot for postprocessing (optional)
+=item * gnuplot for postprocessing (optional)
 
 =back
 
@@ -1268,11 +1279,13 @@
 
 =head1 DESCRIPTION
 
-SynSim is a generic template-driven simulation automation tool. It works with any simulator that accepts text input files and generates text output (and even those that don't. See L<EXAMPLES> for special cases). It executes thousands of simulations with different input files automatically, and processes the results. Postprocessing facilities include basic statistical analysis and automatic generation of PostScript plots with Gnuplot. SynSim is entirely modular, making it easy to add your own analysis and postprocessing routines.
+SynSim is a generic template-driven simulation automation tool. It works with any simulator that accepts text input files and generates text output (and even those that don't. See L</"EXAMPLES"> for special cases). It executes thousands of simulations with different input files automatically, and processes the results. Postprocessing facilities include basic statistical analysis and automatic generation of PostScript plots with Gnuplot. SynSim is entirely modular, making it easy to add your own analysis and postprocessing routines.
 
 =head1 INSTALLATION
 
-=over
+=head2 1. Download and extract the archive
+
+=over 4
 
 =item 1.
 Download the gzipped tar file F<Simulation-Automate-0.9.5.tar.gz>
@@ -1280,58 +1293,127 @@
 =item 2.
 Extract the archive:
 
-	tar -xvf Simulation-Automate-0.9.5.tar.gz
-
-=item 3.
-Create the Makefile:
+	tar -zxvf Simulation-Automate-0.9.5.tar.gz
 
-	cd Simulation-Automate-0.9.5
-	perl Makefile.PL
+=back
 
-=item 4.
-Make Simulation::Automate:
+=head2 2. Simple local installation
 
-	make
+This installation procedure will install the Simulation::Automate modules in a directory of your choice, and create a template directory structure for your SynSim project.
 
-=item 5.
-Test Simulation::Automate:
+=over 4
 
-	 make test
+=item 1. Run the local install script:
 
-=item 6.
-Install Simulation::Automate:
+In the main directory of the distribution (i.e. the directory which contains the file C<local_install.pl>), type:
 
-	 make install
+   perl local_install.pl
 
-=item 7.
-For a local installation (if you don't have root access):
+=item 2. Enter the installation directory
 
-	 make localinstall
+The install script asks for the name of the directory in which it will put SynSim:
 
-or
+   Local SinSym directory? [/local/home/wim/SynSim]:
 
-	 perl -e "use Simulation::Automate;&Simulation::Automate::localinstall();"
+If you enter just a name, the installer assumes that the directory is in your home directory. If you want to install SynSim outside your home directory, enter a full path.
 
-=item 8.
-Setup your local SynSim project (SynSim is the name for the tool contained in Simulation::Automate). This creates the directory structure for your simulations:
+=item 3. Enter the project directory name
 
-	 make setup
-or
+The install script asks for the name of directory where you will run SynSim:
 
-	 perl -e "use Simulation::Automate;&Simulation::Automate::setup();"
+    Simulation project directory? [SynSimProject]:
 
+This directory is a subdirectory of the local SynSim directory.
 
 =back
 
-The archive structure is as follows:
+That's it. Now you can go to your project directory and run the synsim script as a test:
 
-	README    
-	Makefile.PL	  
-        Automate.pm
-	Automate/
-                Remote.pm
-        	PostProcLib.pm
-                Analysis.pm
+    ./synsim
+
+This will run a simple test. If the installation was succesful, it will display the follwing message:
+
+    SynSim Installation Test
+ 
+    Simulation::Automate version 0.9.6
+ 
+    installed locally in /home/wim/SynSim/Test
+ 
+    Finished SynSim run
+ 
+
+=head2 3. Perl-style installation
+
+This is the typical Makefile.PL-driven installation procedure. It is only required for system-wide installation, but it works for local installation as well.
+
+=over
+
+=item 1.
+Create the Makefile:
+
+	cd Simulation-Automate-0.9.5
+	perl Makefile.PL
+
+=item 2.
+Make Simulation::Automate:
+
+	make
+
+=item 3.
+Test Simulation::Automate:
+
+	make test
+
+=item 4.
+Install Simulation::Automate:
+
+This requires you to be root:
+
+	su
+	make install
+
+or
+
+	sudo make install
+
+
+=item 5.
+For a local installation 
+
+This does not require you to be root:
+
+	make localinstall
+
+or
+
+	perl -e "use Simulation::Automate;
+                 &Simulation::Automate::localinstall();"
+
+=item 6.
+Setup your local SynSim project (
+
+SynSim is the name for the tool contained in Simulation::Automate. This step creates the directory structure for your simulations:
+
+	make setup
+or
+
+	perl -e "use Simulation::Automate;
+                 &Simulation::Automate::setup();"
+
+=back
+
+=head2 4. Archive structure
+
+The archive structure is as follows:
+
+	README    
+	Makefile.PL	  
+        Automate.pm
+        local_install.pl
+	Automate/
+                Remote.pm
+        	PostProcLib.pm
+                Analysis.pm
 		Dictionary.pm
              	PostProcessors.pm
 
@@ -1347,76 +1429,104 @@
 			bufsim3.cc
 			MersenneTwister.h
 		TEMPLATES/		
+			test.templ
 			DEVTYPES/
 			SIMTYPES/
 				bufsim3.templ
+		PLUGINS/		
 
 
 =head1 CONFIGURATION
 
-SynSim must be configured for use with your simulator. This is done by providing template and source files, creating (or modifying) datafiles and (optionally) customizing some modules for postprocessing the simulation results. All files must be put in a particilar directory structure:
+To configure SynSim for use with your simulator, you must create a set of files in your SynSim project directory structure. This paragraph gives an overview of the different types of files and their place in the SynSim project directory structure.  
+
+=head2 SynSim project directory structure
+
+You can create a SynSim directory structure with C<perl local_install.pl> or C<make setup> (see L</"INSTALLATION"> for details). If you already have an existing project, you can do this:
 
-=head2 Directory structure
+=over 4
 
-You can use "make setup"  to create a SynSim directory structure. If you want to create it manually, this is the structure:
+=item *
+Create a new project directory:
+
+        mkdir NewProject
+
+=item *
+Copy the C<synsim> script from the old project:
+
+        cp oldProject/synsim NewProject
+
+=item *
+Go to the C<NewProject> directory and run C<synsim> with the C<-D> option:
+
+        cd NewProject
+        ./synsim -D
+
+=back
+
+If you want to create it manually, this is the structure. Directories between square brackets are optional.
 
 	YourProject/
 			synsim	
 			YourDataFile.data
 			[SOURCES/]
 			TEMPLATES/		
-				 [DEVTYPES/]
-				 SIMTYPES/
 					YourSimTempl.templ
-
+				 [DEVTYPES/]
+				 [SIMTYPES/]
+				 [PLUGINS/]
 	[Simulation/SynSim/]
 				[Dictionary.pm]
 				[PostProcessors.pm]			
 
-The synsim script contains the 2 lines from the L<SYNOPSIS>. 
-The local Simulation/Automate modules are only required if you want to customize the postprocessing (highly recommended). 
+The C<synsim> script is the actual script that runs the DOE. It contains the 2 lines from the L</"SYNOPSIS">.  
+The local Simulation/Automate modules are only required if you want to customize the postprocessing. 
  
 =head2 Source files
 
-Copy all files which are needed "read-only" by your simulator (e.g. header files, library files) to F<SOURCES/>. This directory is optional.
+The directory F<SOURCES/> is optional. It should contain all files which are required "read-only" by your simulator (e.g. header files, library files, wrappers).
 
 =head2 Template files
 
-Template files are files in which simulation variables will be substituted by their values to create the input file for your simulator. SynSim can create an input file by combining two different template files, generally called device templates and simulation templates. This is useful in case you want to run different types of simulations on different devices, e.g. DC analysis, transient simulations, small-signal and noise analysis  on 4 different types of operation amplifiers. In total, this requires 16 different input files, but only 8 different template files (4 for the simulation type, 4 for the device types).
+Template files are files in which simulation variables will be substituted by their values to create the input file for your simulator. They must be stored in the F<TEMPLATES/> directory, and have by convention the extension C<.templ>.
 
-=over
+B<SynSim variable format>
 
-=item 1.
+The template file format is free, but the variables to be substituted by SynSim I<must> be in uppercase and start with an underscore:
 
-To create a template file, start from an existing input file for your simulator. Replace the values of the variables to be modified by SynSim by a SynSim variable name (e.g. 
-var1 = 2.5 => var1 = _VAR1). 
-
-=item 2.
+Examples:
 
-Put the template files in F<TEMPLATES/SIMTYPES> and F<TEMPLATES/DEVTYPES>.
+        _VAR1
+        _LONG_VARIABLE_NAME
 
+To create a template file, start from an existing input file for your simulator. Replace the values of the variables to be modified by SynSim by a SynSim variable name (e.g. 
+var1 = 2.5 => var1 = _VAR1). Put the template files in F<TEMPLATES>.
 
-There must be at least one template file in F<SIMTYPES>; files in F<DEVTYPES> are optional.
-SynSim will check both directories for files as defined in the datafile. If a matching file is found in F<DEVTYPES>, it will be prepended to the simulation template from F<SIMTYPES>. This is useful if the datafile defines multiple simulation types on a particular device (See L<DATAFILE DESCRIPTION> for more information).
-
-=back
 
-B<NOTE:>
+B<Note:> Relative paths to source files
 
 SynSim creates a run directory ath the same level as the SOURCES and TEMPLATES directories. All commands (compilations etc.) are executed in that directory. As a consequence, paths to source files (e.g. header files) should be "C<../SOURCES/>I<sourcefilename>".
 
+B<Note:> The F<DEVTYPES/> and F<SIMTYPES/> subdirectories 
+
+SynSim can create an input file by combining two different template files, generally called device templates and simulation templates. This is useful in case you want to run different types of simulations on different devices, e.g. DC analysis, transient simulations, small-signal and noise analysis  on 4 different types of operational amplifiers. In total, this requires 16 different input files, but only 8 different template files (4 for the simulation type, 4 for the device types). If you want to use this approach, device templates should go in F<TEMPLATES/DEVTYPES/> and simulation templates in  F<TEMPLATES/SIMTYPES/>. 
+SynSim will check both directories for files as defined in the datafile. If a matching file is found in F<DEVTYPES>, it will be prepended to the simulation template from F<SIMTYPES>. 
 
 =head2 Datafile
 
-The datafile is the input file for synsim. It contains the list of simulation variables and their values to be substituted in the template files, as well as a number of configuration variables (See L<DATAFILE DESCRIPTION> for more information).
+The datafile is the input file for C<synsim>. It contains the list of simulation variables and their values to be substituted in the template files, as well as a number of configuration variables. See L</"DATAFILE DESCRIPTION"> for more information.
+
+=head2 Postprocessing and Preprocessing (optional)
+
+The F<PostProcessing.pm> module contains routines to perform postprocessing on the simulation results (e.g. plotting, statistical analysis, etc). A number of generic routines are provided, as well as a library of functions to make it easier to develop your own postprocessing routines. See L</"POSTPROCESSING"> for a full description). 
 
-=head2 Postprocessing (optional)
+Before the raw data are sent to the postprocessor, it is possible (and very easy) to preprocess the raw data.  See L</"PREROCESSING"> for more details. 
 
-The F<PostProcessing.pm> module contains routines to perform postprocessing on the simulation results. A number of generic routines are provided, as well as a library of functions to make it easier to develop your own postprocessing routines. See L<POSTPROCESSING> for a full description).
+Custom postprocessing and preprocessing routines can either be stored in the F<PLUGINS/> directory (preferred) or directly in the local F<PostProcessing.pm> module (more intended for modified versions of the generic routines).
 
 =head2 Dictionary (optional)
 
-The F<Dictionary.pm> module contains descriptions of the parameters used in the simulation. These descriptions are used by the postprocessing routines to make the simulation results more readable. See L<DICTIONARY> for a full description).
+The F<Dictionary.pm> module contains descriptions of the parameters used in the simulation. These descriptions are used by the postprocessing routines to make the simulation results more readable. See L</"DICTIONARY"> for a full description).
 
 =head1 DATAFILE DESCRIPTION
 
@@ -1426,7 +1536,7 @@
 
 The datafile is a case-sensitive text file with following syntax:
 
-=over
+=over 4
 
 =item Comments and blanks
 
@@ -1443,11 +1553,19 @@
 
 =item Lists of values
 
-Lists of values have one or more items. Valid list separators are ',',';' and, for a 2-element list, '..'.
+Lists of values have one or more items. The list separator is a comma ','.
+
+Example:
+
+	_PAR1 = 1,1,2,3,5,8,13
+
+If a list has 3 elements START,STOP,STEP, then if possible this list will be expanded as a for-loop from START to STOP with step STEP.
+
+Example:
 
-If a (','- or ';'-separated) list has 3 elements START,STOP,STEP |START|<|STOP| and |STEP|<|STOP-START|, then this list will be expanded as a for-loop from START to STOP with step STEP.
+       _NBUFS = 16,64,8 #  from 16 to 64 in steps if 8: 16,24,32,40,48,56,64
 
-=item Section headers for multiple simulation types
+=item Section headers for multiple simulation types (optional)
 
 These must be lines containing only the simulation type 
 
@@ -1456,11 +1574,10 @@
 =head2 Simulation variables 
 
 The main purpose of the datafile is to provide a list of all variables and their values to be substituted in the template files. 
-The lists of values for the variables can be used in two different ways: 
 
-=over
+=over 4
 
-=item Comma-separated list: combine values
+=item Default behaviour: combine values
 
 A simulation will be performed for every possible combination of the values for all parameters. 
 
@@ -1474,86 +1591,83 @@
 Simulation results for all values in ','-separated list are stored in a separate files.
 
 
-=item Semicolon-separated list: pair values
+=item Alternative behaviour: group values
 
-If more than one ';'-separated list exists, they must have the same number of items. The values of all parameters at the same position in the list will be used.
+It is possible (See the keyword B<GROUP> under L</"Configuration variables">) to define groups of variables. For every parameter in a group, the value list must have the same number of items. The values of all variables at the same position in the list will be used.
 
 Example:
 
+	GROUP: _PAR1,_PAR2
+
 	_PAR1 = 0;1;2;4
 	_PAR2 = 3;4;5;6
 
-defines 3 simulations: (_PAR1,_PAR2)=(0,3);(1,4);(2,5);(4,6)
-
-Values from ';'-separated lists are processed one after another while are values for all others parameters are kept constant. In other words, the ';'-separated list is the innermost of all nested loops.
+defines 4 simulations: (_PAR1,_PAR2)=(0,3);(1,4);(2,5);(4,6)
 
-Simulation results for all values in the ';'-separated list are stored in a common file. For this reason, ';'-separated lists are preferred as sweep variables (X-axis values), whereas ','-separated lists are more suited for parameters (sets of curves).
+=back
 
-Example: consider simulation of packet loss vs number of buffers with 3 types of buffer and 2 different traffic distributions.
+=head2 Configuration variables
 
-	_NBUFS = 4;8;16;32;64;128
-	_BUFTYPE = 1,2,3
-	_TRAFDIST = 1,2
+A number of variables are provided to configure SynSim's behaviour:
 
-This will produces 6 files, each file containing the simulation results for all values of _NBUFS. A plot of this simulation would show a set of 6 curves, with _NBUFS as X-axis variable.
+=over 4
 
-=item Semicolon-separated from;to;step list
+=item TITLE
 
-This is a special case where the list has exactly three elements From;To;Step and following condition holds:
+The title of the DOE. This title is used on the plots, but typically it is the first line of the datafile and describes the DOE.
 
-  (|From|<|To|) AND (|Step|<|To-From|)
+=item TEMPLATE
 
-Example:
+B<Alternative names:> SIMULATION, SIMTEMPL, SIMTYPE
 
-       _NBUFS = 16;64;8 #  from 16 to 64 in steps if 8: 16;24;32;40;48;56;64
+The name of the template file, with or without extension. By convention, this is the same as the type of simulation to be performed. If no extension is given, SynSIm checks for a B<TEMPLEXT> keyword; if this is not defined, the extenstion defaults to C<.templ>. SynSim will look for the template file in F<TEMPLATES/> and F<TEMPLATES/SIMTYPES/>.
 
-=item Double dotted list
+B<Note:> Multiple simulation types
 
-This is a shorthand for a ';'-separated list if the value increase in steps of 1. E.g. 0..7 is equivalent to 0;1;2;3;4;5;6;7.
+The value of SIMULATION can be a ','-separated list. In this case, SynSim will use the datafile for multiple types of simulations. Every item in the list can be used as a section header, demarkating a section with variables particular to that specific simulation. 
 
-=back
+=item TEMPLEXT (optional)
 
-=head2 Configuration variables
+Extension of template files (default: C<.templ>)
 
-A number of variables are provided to configure SynSim's behaviour:
+=item DEVTYPE (optional)
 
-=over
+The name of the device on which to perform the simulation. If defined, SynSim will look in TEMPLATES/DEVTYPES for a file with TEMPL and DEVTYPE, and prepend this file to the simulation template before parsing. This keyword can take a list of values
 
-=item INCLUDE (optional)
+=item COMMAND
 
-If the value of INCLUDE is an exisiting filename, this datafile will be included on the spot.
+The command line for the program that runs the input file, i.e. the simulator command (default: perl). SynSim looks for the words B<INPUTFILE> and <OUTPUTFILE> and substitutes them with the actual file names.
 
-=item COMMAND
+Examples:
 
-The program that runs the input file, i.e. the simulator command (default: perl).
+        yoursim1 -i INPUTFILE -o OUTPUTFILE
+        yoursim2 INPUTFILE > OUTPUTFILE
 
 =item EXT
 
 Extension of input file (default: .pl)
 
-=item TEMPL
-
-Extension of template files (default: .templ)
+Some simulators expect a particular extension for the input file. This can be specified with the keyword B<EXT>.
 
-=item SIMTYPE
+=item INCLUDE (optional)
 
-The type of simulation to perform. This can be a ','-separated list. SynSim will look in TEMPLATES/SIMTYPES for a file with TEMPL and SIMTYPE
+If the value of INCLUDE is an exisiting filename, this datafile will be included on the spot.
 
-=item DEVTYPE (optional)
+=item OUTPUT_FILTER_PATTERN (optional)
 
-The name of the device on which to perform the simulation. If defined, SynSim will look in TEMPLATES/DEVTYPES for a file with TEMPL and DEVTYPE, and prepend this file to the simulation template before parsing.
+A Perl regular expression to filter the output of the simulation (default : .*). Tis is very usefull for very verbose simulators. The results file will only contain the filtered output.
 
-=item OUTPUT_FILTER_PATTERN
+=item ANALYSIS
 
-A Perl regular expression to filter the output of the simulation (default : .*).
+B<Alternative names:> ANALYSIS_TEMPLATE, ANATEMPL
 
-=item ANALYSIS_TEMPLATE
+Name of the routine to be used for the result analysis (postprocessing). This routine must be defined in PostProcessors.pm or in a file in the F<PLUGINS/> directory. A number of generic routines are provided, see L</"POSTPROCESSING">.
 
-Name of the routine to be used for the result analysis (postprocessing). This routine must be defined in PostProcessors.pm (default: SweepVar, a generic routine which assumes a sweep for one variable and uses all others as parameters).
+=item XVAR (optional)
 
-=item SWEEPVAR (optional)
+B<Alternative name:> SWEEPVAR
 
-The name of the variable to be sweeped. Mandatory if the postprocessing routine is SweepVar. 
+The name of the variable to be sweeped. Mandatory if the postprocessing routine is XYPlot. 
 
 =item NORMVAR (optional)
 
@@ -1563,21 +1677,23 @@
 
 The number of times the simulation has to be performed. For statistical work.
 
-=item DATACOL (optional)
+=item YCOL (optional)
 
-The column in the output file which contains simulation results (default: 2). Mandatory if using any of the generic postprocessing routines. 
+B<Alternative name:> DATACOL
 
-=item TITLE (optional)
+The column in the output file which contains the simulation results (default: 2). Mandatory if using any of the generic postprocessing routines. 
 
-String describing the simulation, for use in the postprocessing.
+=item XCOL (optional)
 
-=item XLABEL, YLABEL, LOGSCALE, STYLE
+The column in the output file which contains the X-values.
 
-Variables to allow more flexibility in the customization of the plots. XLABEL and YLABEL are the X and Y axis labels. LOGSCALE is either X, Y or XY, and results in a logarithmic scale for the chosen axis. STYLE is the gnuplot plot style (lines, points etc)
+=item PREPROCESSOR (optional)
 
-=item XTICS, YTICS, XSTART, XSTOP, YSTART, YSTOP
+The name of a function which modifies C<@results> before the actual postprocessing. Very usefull to "streamline" the raw results for postprocessing.
 
-Variables to allow more flexibility in the customization of the plots (not implemented yet).
+=item XLABEL, YLABEL, LOGSCALE, PLOTSTYLE, XTICS, YTICS, XSTART, XSTOP, YSTART, YSTOP (optional)
+
+Variables to allow more flexibility in the customization of the plots. XLABEL and YLABEL are the X and Y axis labels. LOGSCALE is either X, Y or XY, and results in a logarithmic scale for the chosen axis. PLOTSTYLE and following are identical to the corresponding C<gnuplot> keywords, see the gnuplot documentation for details.
 
 =back
 
@@ -1599,9 +1715,99 @@
 The variables used in the expressions must be defined in the datafile, although not upfront. Using circular references will not work.
 The expression syntax is Perl syntax, so any Perl function can be used. Due to the binding rules, it is necessary to enclose expressions using the ternary operator ?: with brackets (see example).
 
-The next sections (L<DICTIONARY> and L<POSTPROCESSING>) are optional. For instructions on how to run SynSim, go to L<RUNNING SYNSIM>.
+=head1 RUNNING SYNSIM
+
+The SynSim script must be executed in a subdirectory of the SynSim
+directory which contains the TEMPLATES subdir and the datafile (like the Example directory in the distribution). 
+
+The command line is as follows:
+
+	./synsim [-h -D -i -p -P -v -N ] [datafile] [remote hostname]
+
+The C<synsim> script supports following command line options:
+
+	none: defaults to -f synsim.data
+	 -D : Create an empty SynSim directory structure in the current directory.
+	 -v : 'verbose'. Sends simulator output to STDOUT
+	 -i : interactive. Calls gv or ggv to display a plot of the results.
+              Implies -p -v.  
+	 -p : plot. This enables generation of postscript plots via gnuplot. 
+              A postprocessing routine is required to generate the plots.
+	 -P : Plot. This option can be used to display plots created with -p.
+	 -w : 'warnings'. Show warnings about undefined variables.
+	 -N : 'No simulations'. Performs only postprocessing.
+	 -h, -? : short help message
+
+If [remote hostname] is provided, SynSim will try to run the simulation on the remote host.
+
+The current implementation requires:
+
+-ssh access to remote host
+
+-scp access to remote host
+
+-rsync server on the local host
+
+-or,alternatively, an NFS mounted home directory
+
+-as such, it will (probably) only work on Linux and similar systems
+
+
+=head1 POSTPROCESSING
+
+Postprocessing of the simulation results is handled by routines in the C<PostProcessors.pm> module. This module uses the C<PostProcLib.pm> and optionally C<Dictionary.pm> and C<Analysis.pm>.
+
+=head2 Generic Postprocessors
+
+SynSim comes with a number of generic postprocessing routines. 
+
+=over 4
+
+=item XYPlot
+
+Required configuration variables: C<XVAR>
+
+Creates a plot using C<XVAR> as X-axis and all other variables as parameters. This routine is completely generic. 
+
+=item CondXYPlot
+
+Required configuration variables: C<XVAR>,C<CONDVAR> and C<CONDITION>. 
 
+Creates a plot using C<SETVAR> as X-axis; C<XVAR> is checked against the condition C<COND> (or C<CONDITION>). The first value of C<CONDVAR> that meets the condition is plotted. All other variables are parameters. This routine is completely generic. 
 
+=item XYPlotErrorBars
+
+Required configuration variables: C<XVAR>, C<NRUNS>
+
+Optional configuration variables: C<NSIGMAS>
+
+Creates a plot using C<XVAR> as X-axis and all other variables as paramters. Calculates average and 95% confidence intervals for C<NRUNS> simulation runs and plots error flags. This routine is fully generic, the confidence interval (95% by default) can be set with NSIGMAS. See eg/ErrorFlags.data for an example datafile. 
+
+=item Histogram
+
+Required configuration variables: C<NBINS>
+
+Optional configuration variables: C<BINWIDTH>, C<MIN>, C<MAX>
+
+Creates a histogram of the simulation results. This requires the simulator to produce raw data for the histograms in a tabular format. When specifying logscale X or XY for the plot, the histogram bins will be logarithmic. See eg/Histogram.data for an example. 
+The number of bins in the histogram must be specified via C<NBINS>. The width of the bins can be set with C<BINWIDTH>, in which case  C<MIN> and C<MAX> will be calculated. When  C<MIN> or C<MAX> are set, C<BINWIDTH> is calculated. It is possible to specify either C<MIN> or C<MAX>, the undefine value will be calculated. 
+
+=back
+
+=head2 Preprocessing the raw results
+
+All of the above routines have hooks for simple functions that modify the C<@results> array. To call these functions, include them in the datafile with the C<PREPROCESSOR> variable. e.g:
+
+  PREPROCESSOR : modify_results
+
+  All functions must be put in the PLUGINS folder or in the PostProcessors.pm module, and the template could be like this:
+
+  sub modify_results {
+  foreach my $results_line (@results) {
+	  #Do whatever is required
+  }
+  
+  } # End of modify_results
 
 =head1 DICTIONARY
 
@@ -1630,309 +1836,230 @@
 
 	);
 
-=head1 POSTPROCESSING
-
-Postprocessing of the simulation results is handled by routines in the C<PostProcessors.pm> module. This module uses the C<PostProcLib.pm> and C<Analysis.pm>.
+=head1 OUTPUT FILES
 
-=head2 PostProcessors
+SynSim creates a run directory C<{SIMTYPE}->I<[datafile without .data]>. It copies all necessary template files and source files to this directory; all output files are generated in this directory.
 
-Routines to perform analysis on the simulation results in the PostProcessors module. In general you will have to create your own routines, but the version of C<PostProcessors.pm> in the distribution contains a number of more or less generic postprocessing routines. All of these have hooks for simple functions that modify a file in-place. To call these functions, include them in the datafile with the C<PREPROCESSOR> variable. e.g:
+SynSim generates following files:
 
-  PREPROCESSOR : modify_results_file
+=over 4
 
-All functions must be put in PostProcessors.pm, and the template could be like this:
+=item *
 
-  sub modify_results_file {
-  my $resultsfile=shift;
+Output files for all simulation runs. 
   
-  open(IN,"<$resultsfile");
-  open(TMP,">$resultsfile.tmp");
-  while(<IN>) {
-  #Do whatever is required
-  }
-  close IN;
-  close TMP;
-  rename "$resultsfile.tmp","$resultsfile" or die $!;
-  }
+The names of these files are are C<{SIMTYPE}_C>I<[counter]_[simulation number]>C<.out>
 
-=over
+I<counter> is increased with every new combination of variables except for C<XVAR>. 
 
-=item SweepVar
+I<simulation number> is the position of the value in the C<XVAR>- list. 
 
-Required configuration variables: C<SWEEPVAR>
+=item *
 
-Creates a plot using C<SWEEPVAR> as X-axis and all other variables as parameters. This routine is completely generic. The C<SWEEPVAR> value list must be semicolon-separated.
+Combined output file for all values in a ';'-separated list. 
 
-=item SweepVarCond
+The names of these files are are C<{SIMTYPE}_C>I<[counter]>C<_.out> 
 
-Required configuration variables: C<SETVAR>,C<SWEEPVAR> and C<CONDITION>. 
+I<counter> is increased with every new combination of variables in ','-separated lists. 
 
-Creates a plot using C<SETVAR> as X-axis; C<SWEEPVAR> is checked against the condition C<COND> (or C<CONDITION>). The first value of C<SWEEPVAR> that meets the condition is plotted. All other variables are parameters. This routine is completely generic. The C<SWEEPVAR> value list must be semicolon-separated.
+Only the lines matching C</OUTPUT_FILTER_PATTERN/> (treated as a Perl regular expression) are put in this file.
 
-=item ErrorFlags
+=item *
 
-Required configuration variables: C<SWEEPVAR>, C<NRUNS>
+Combined output file for all values in a ';'-separated list, with a header detailing all values for all variables. 
 
-Optional configuration variables: C<NSIGMAS>
+The names of these files are are C<{SIMTYPE}_C>I<[counter]>C<.res>, 
 
-Creates a plot using C<SWEEPVAR> as X-axis and all other variables as paramters. Calculates average and 95% confidence intervals for C<NRUNS> simulation runs and plots error flags. This routine is fully generic, the confidence interval (95% by default) can be set with NSIGMAS. See eg/ErrorFlags.data for an example datafile. The C<SWEEPVAR> value list must be semicolon-separated.
+I<counter> is increased with every new combination of variables in ','-separated lists.  
 
-=item Histogram
+Only the lines in the C<.out> files matching C</OUTPUT_FILTER_PATTERN/> (treated as a Perl regular expression) are put in this file.
 
-Required configuration variables: C<NBINS>
 
-Optional configuration variables: C<BINWIDTH>, C<OUTPUT_FILTER_PATTERN>, C<NSIGMAS>
+=item *
 
-Creates a histogram of the simulation results. This requires the simulator to produce raw data for the histograms in a tabular format. The configuration variable C<OUTPUT_FILTER_PATTERN> can be used to 'grep' the simulator output. When specifying logscale X or XY for the plot, the histogram bins will be logarithmic. See eg/Histogram.data for an example. 
-The number of bins in the histogram must be specified via C<NBINS>. The width of the bins can be set with C<BINWIDTH>.
+Separate input files for every item in a ';'-separated list. 
 
-=back
+The names of these files are are C<{SIMTYPE}_>I<[simulation number]>C<.{EXT}>
 
-=head2 PostProcLib
+I<simulation number> is the position of the value in the list. 
 
-In a lot of cases you will want to create your own postprocessing routines. To make this easier, a library of functions is at your disposal. This library resides in the C<PostProcLib.pm> module. 
+These files are overwritten for every combination of variables in ','-separated lists.
 
-Following functions are exported:
+=back
 
-			   &prepare_plot	# does what it says. see example below
-			   &gnuplot		# idem. Just pipes the first argument string to gnuplot. The option -persist can be added to keep the plot window after gnuplot exits.
-			   &gnuplot_combined	# See example, most useful to create nice plots. Looks for all files matching ${simtempl}-${anatempl}-*.res, and creates a line in the gnuplot script based on a template you provide.	
-
-Following variables are exported (see PostProcLib.pm for a full list):
-
-			   %simdata		# contains all simulation variables and their value lists
-			   @results		# an array of all results for a sweep (i.e. a var with a ';'-sep. value list
-			   $sweepvar		# SWEEPVAR
-			   $normvar		# NORMVAR
-			   $sweepvals		# string containing all names and values of parameters for the sweep, joined with '-'
-			   $datacol		# DATACOL
-			   $count		# cfr. OUTPUT FILES section
-			   $simtempl		# SIMTYPE
-			   $anatempl		# ANALYSIS_TEMPLATE
-			   $dirname		# name of run directory. cfr. OUTPUT FILES section
-			   $last		# indicates end of a sweep
-			   $verylast		# indicates end of all simulations
-			   $sweepvartitle	# title for SWEEPVAR (from Dictionary.pm) 
-			   $title		# TITLE 
-			   $legend		# plot legend (uses Dictionary.pm)
-			   $legendtitle		# plot legend title (uses Dictionary.pm)
-                           $xlabel		# XLABEL	
-                           $ylabel		# YLABEL	
-                           $logscale		# LOGSCALE
-			   $plot		# corresponds to -p flag
-			   $interactive		# corresponds to -i flag
 
-An example of how all this is used:
+=head1 WRITING POSTPROCESSING ROUTINES
 
-	sub YourRoutine {
-	## Unless you want to dig really deep into the code, start all your routines like this:
-	## Get all arguments, to whit: $datafilename,$count,$dataref,$flagsref,$returnvalue
-	my @args=@_; 
-	## But don't bother with these, following function does all the processing for you:
-	&prepare_plot(@args);
+In a lot of cases you will want to create your own postprocessing routines. First of all, it is important to understand the SynSim output, so make sure you have read L</"OUTPUT FILES">. Apart from that, there is a very simple API. 
 	
-	## this makes all above-listed variables available
+=head2 PostProcLib
 	
-	## Define your own variables.
-	## As every variable can have a list of values, 
-	## $simdata{'_YOURVAR1'} is an array reference.
+=over
 	
-	my $yourvar=${$simdata{'_YOURVAR1'}}[0];
+=item *
+All variables from the datafile are exported in a hash called C<%simdata>
 	
-	my @sweepvarvals=@{$simdata{$sweepvar}};
+The value list for every variable is a Perl list. This means that you can access the values like this:
 	
-	## $verylast indicates the end of all simulations
-	if($verylast==0) {
+        my @importantvars = @{$simdata{_VAR1}}
 	
-	## what to do for all simulations
+or
 	
-	## example: parse SynSim .res file and put into final files for gnuplot
+        my $importantvar = $simdata{_VAR1}[0]
 	
-	open(HEAD,">${simtempl}-${anatempl}-${sweepvals}.res");
-	open(IN,"<${simtempl}_C$count.res");
-	while(<IN>) {
-		/\#/ && !/Parameters|$sweepvar/ && do {
-		## do something with $_
-		print HEAD $_
-		};
-	}
-	close IN;
-	close HEAD;
+The same holds for configuration variables, but in general they only have a single value, so:
 
-	my $i=0;
-	foreach my $sweepvarval ( @sweepvarvals ) {
-		open(RES,">>${simtempl}-${anatempl}-${sweepvals}.res");
-		print RES "$sweepvarval\t$results[$i]";
-		close RES;
-		$i++;
-	}
+        my $x_variable = $simdata{XVAR}
 
-	## $last indicates the end of a sweep
-	if($last) {
-	  ## $interactive corresponds to the -i flag
-		  if($interactive) {
-		    ## do something, typically plot intermediate results
-		my $gnuplotscript=<<"ENDS";
-		# your gnuplot script here
-		ENDS
+=item *
+Easy-typing names
 	
-		&gnuplot($gnuplotscript);
+Furthermore, every variable can be accessed using a short name. Instead of
 	
-		}		# if interactive
-	  }			# if last
-	} else {
-	 ## On the very last run, collect the results into one nice plot
+        $simdata{_VAR} 
 	
-	## You must provide a template line for gnuplot. Next line is a good working example.
-	## This line will be eval()'ed by the &gnuplot_combined() routine. 
-	## This means the variables $filename and $legend are defined in the scope of this routine. 
-	## Don't locally scoped put variables in there, use the substitution trick as below or some other way.
+you can use
 	
-	#this is very critical. The quotes really matter!
-	# as a rule, quotes inside gnuplot commands must be escaped
+        $_var
 	
-	my $plotlinetempl=q["\'$filename\' using (\$1*1):(\$_DATACOL) title \"$legend\" with lines"];
-	$plotlinetempl=~s/_DATACOL/$datacol/; ##this is a trick, you might try to eval() the previous line or something. TIMTOWDI :-)
+This is especially handy for configuration variables, e.g.
 	
-	my $firstplotline=<<"ENDH";
-	# header for your gnuplot script here
-	ENDH
+        $plotstyle
 	
-	&gnuplot_combined($firstplotline,$plotlinetempl);
-	}
+instead of
 	
-	} #END of YourRoutine()
+        $simdata{PLOTSTYLE}
 
+=item *
+Current set of values for the DOE
 
-=head2 Statistical analysis
+The current set of values for the DOE is available in the hash C<%current_set_vals>. The keys are the variable names, the values the current value for the variable. 
 
-A module for basic statistical analysis is also available (C<Analysis.pm>). Currently, the module provides 2 routines: 
+Example: A simple DOE with 2 variables.
 
-=over
+        _VAR1=1,2,3
+        _VAR2=3,4
 
-=item calc_statistics()
+This DOE has 6 sets. After the fourth run, the values of the set will be: 
 
-To calculate average, standard deviation, min. and max. of a set of values.
+        $current_set_vals{_VAR1}==2
+        $current_set_vals{_VAR1}==4
 
-Arguments:
+The current set is also available in string format through C<$current_set_str>:
 
-	$file: name of the results file. The routine requires the data to be in whitespace-separated columns.  	
-	$par: Determines if the data will be differentiated before processing ($par='DIFF') or not (any other value for $par). Differentiation is defined as subtracting the previous value in the array form the current value. A '0' is prepended to the array to avoid an undefined first point.
-	$datacol: column to use for data
-	$title: optional, a title for the histogram 
-	$log: optional, log of values before calculating histogram or not ('LOG' or '')
+        $current_set_str eq '_VAR1-2-_VAR2-4'
 
-Use:
-	my $file="your_results_file.res";
-	my $par='YOURPAR';
-	my $datacol=2;
-	my %stats=%{&calc_statistics($file,[$par, $datacol])};
+This is useful because this string is part of the name of the  results file.
 
-	my $avg=$stats{$par}{AVG}; # average
-	my $stdev=$stats{$par}{STDEV}; # standard deviation
-	my $min=$stats{$par}{MIN}; # min. value in set
-	my $max=$stats{$par}{MAX}; # max. value in set
+If the configuration variable C<SETVAR> is defined, there is an additional string C<$current_set_except_setvar_str>, which contains the current set except the C<SETVAR>. This is usefull for conditional postprocessing, see e.g. CondXYPlot in PostProcessors.pm.
 
-=item build_histograms()
+=item *
+Raw results 
 
-To build histograms. There are 3 extra arguments:
+The raw results of the last simulation run are available in the array C<@results>. Every element in this array is identical to the corresponding line in the output file for the given simulation run.
 
-	$nbins: number of bins in the histogram
-	$min: force the value of the smallest bin (optional)
-	$max: force the value of the largest bin (optional)
+It is also possible to access the results files: C<$results_file_name> contains the filename of the current results file, and C<@all_results_file_names> is a list of all results files so far.
 
-use:
-	my $par='DATA';
-	my %hists=%{&build_histograms("your_results_file.res",[$par,$datacol],$title,$log,$nbins,$min,$max)};
+=item *
+Deciding when to call the postprocessor.
 
-NOTE: Because the extra arguments are last, the $title and $log arguments can not be omitted. If not needed, supply ''.
+SynSim allows to call your postprocessing routine after every run. However, postprocessing generally only makes sense at certain points in the execution of the DOE. SynSim provide two variables: C<$last>, which indicates the end of a sweep, C<$verylast> which indicates the end of the DOE.
 
 =back
 
+In summary, following variables are exported:
 
-=head1 RUNNING SYNSIM
-
-The SynSim script must be executed in a subdirectory of the SynSim
-directory which contains the TEMPLATES subdir and the datafile (like the Example directory in the distribution). 
-
-The command line is as follows:
-
-	./synsim [-h -i -p -w -v -N -P -f] [datafile] [remote hostname]
-
-The C<synsim> script supports following command line options:
-
-	none: defaults to -f synsim.data
-	 -f [filename]: 'file input'. Expects a file containing info about simulation and device type. 
-	 -p : plot. This enables generation of postscript plots via gnuplot. A postprocessing routine is required to generate the plots.
-	 -i : interactive. Enables generation of a plot on the screen after every iteration. Assumes -p -v.  A postprocessing routine is required to generate the plots.
-	 -v : 'verbose'. Sends simulator output to STDOUT, otherwise to the [rundir]/simlog file
-	 -w : 'warn'. Show warnings about undefined variables
-	 -N : 'No simulations'. Perform only postprocessing.
-	 -P : 'Plot only'. Only plots the generated PostScript file. 
-	 -h, -? : short help message
-
-If [remote hostname] is provided, SynSim will try to run the simulation on the remote host.
-
-The current implementation requires:
-
--ssh access to remote host
+			   %simdata		# contains all datafile variables 
+                                                #and their values/value lists
+			   @results		# memory image of the results file
+			   %current_set_vals    # values for the current set 
+                           $current_set_str     # same in string format 
+			   $current_set_except_setvar_str
+			   $results_file_name    
+			   @all_results_file_names
+			   $last		# indicates end of a sweep
+			   $verylast		# indicates end of the DOE
 
--scp access to remote host
+An example of how all this is used:
 
--rsync server on the local host
+	sub YourRoutine {
 
--or,alternatively, an NFS mounted home directory
+	## Define your own variables.
+	## As every variable can have a list of values, 
+	## $simdata{'_YOURVAR1'} is an array reference.
 
--as such, it will (probably) only work on Linux and similar systems
+	my $yourvar=${$simdata{'_YOURVAR1'}}[0];
 
-=head1 OUTPUT FILES
+	my @sweepvarvals=@{$simdata{$sweepvar}};
 
-SynSim creates a run directory C<{SIMTYPE}->I<[datafile without .data]>. It copies all necessary template files and source files to this directory; all output files are generated in this directory.
+	## $verylast indicates the end of all simulations
+	if(not $verylast) {
 
-SynSim generates following files:
+	## what to do for all simulations
 
-=over
+	## $last indicates the end of a sweep
+	if($last) {
+        # Do something at the end of every sweep  
+	  } # if last
+	} else {
+	 ## On the very last run, collect the results into one nice plot
+	  &gnuplot_combined($firstplotline,$plotlinetempl);
+	}
 
-=item *
+	} #END of YourRoutine()
 
-Output files for all simulation runs. 
 
-The names of these files are are C<{SIMTYPE}_C>I<[counter]_[simulation number]>C<.out>
+=head2 Statistical analysis
 
-I<counter> is increased with every new combination of variables in ','-separated lists 
+A module for basic statistical analysis is also available (C<Analysis.pm>). Currently, the module provides 2 routines: 
 
-I<simulation number> is the position of the value in the ';'-separated list. 
+=over 4
 
-=item *
+=item calc_statistics():
 
-Combined output file for all values in a ';'-separated list. 
+To calculate average, standard deviation, min. and max. of a set of values.
 
-The names of these files are are C<{SIMTYPE}_C>I<[counter]>C<_.out> 
+Arguments:
 
-I<counter> is increased with every new combination of variables in ','-separated lists. 
+C<$file>: name of the results file. The routine requires the data to be in whitespace-separated columns.  	
 
-Only the lines matching C</OUTPUT_FILTER_PATTERN/> (treated as a Perl regular expression) are put in this file.
+C<$par>: Determines if the data will be differentiated before processing ($par='DIFF') or not (any other value for $par). 
+              Differentiation is defined as subtracting the previous value in the 
+              array form the current value. A '0' is prepended to the array to avoid 
+              an undefined first point.
 
-=item *
+C<$datacol>: column to use for data
 
-Combined output file for all values in a ';'-separated list, with a header detailing all values for all variables. 
+C<$title>: optional, a title for the histogram 
 
-The names of these files are are C<{SIMTYPE}_C>I<[counter]>C<.res>, 
+C<$log>: optional, log of values before calculating histogram or not ('LOG' or '')
 
-I<counter> is increased with every new combination of variables in ','-separated lists.  
 
-Only the lines in the C<.out> files matching C</OUTPUT_FILTER_PATTERN/> (treated as a Perl regular expression) are put in this file.
+Use:
+	my $file="your_results_file.res";
+	my $par='YOURPAR';
+	my $datacol=2;
+	my %stats=%{&calc_statistics($file,[$par, $datacol])};
 
+	my $avg=$stats{$par}{AVG}; # average
+	my $stdev=$stats{$par}{STDEV}; # standard deviation
+	my $min=$stats{$par}{MIN}; # min. value in set
+	my $max=$stats{$par}{MAX}; # max. value in set
 
-=item *
+=item build_histograms():
 
-Separate input files for every item in a ';'-separated list. 
+To build histograms. There are 3 extra arguments:
 
-The names of these files are are C<{SIMTYPE}_>I<[simulation number]>C<.{EXT}>
+	$nbins: number of bins in the histogram
+	$min: force the value of the smallest bin (optional)
+	$max: force the value of the largest bin (optional)
 
-I<simulation number> is the position of the value in the list. 
+use:
+	my $par='DATA';
+	my %hists=%{&build_histograms("your_results_file.res",
+                  [$par,$datacol],$title,$log,$nbins,$min,$max)};
 
-These files are overwritten for every combination of variables in ','-separated lists.
+NOTE: Because the extra arguments are last, the $title and $log arguments can not be omitted. If not needed, supply ''.
 
 =back
 
@@ -1946,7 +2073,7 @@
 
 With SynSim:
 
-=over
+=over 4
 
 =item 1. Create a template file
 
@@ -1968,16 +2095,16 @@
   COMMAND : spice -b inputfile > outputfile
 
   # Required for postprocessing 
-  OUTPUT_FILTER_PATTERN : id # keep only the drain current on the output file
+  OUTPUT_FILTER_PATTERN : Id # keep only the drain current on the output file
   ANALYSIS_TEMPLATE : SweepVar # default template for simple sweep
   SWEEPVAR : _L # we sweep the length, the other variables are parameters
   DATACOL: 2 # first col is the name 
 
-  _L = 1u;2u;5u;10u;20u;50u
+  _L = 1u,2u,5u,10u,20u,50u
   _W = 10u,100u
   _MODEL = nch
 
-There are more possible keywords, cf. L<DATAFILE DESCRIPTION>.
+There are more possible keywords, cf. L</"DATAFILE DESCRIPTION">.
 
 =item 3. Now run synsim
 
@@ -2006,7 +2133,7 @@
 
 With SynSim:
 
-=over
+=over 4
 
 =item 1. Create a template file
 
@@ -2048,7 +2175,7 @@
 
 With SynSim:
 
-=over
+=over 4
 
 =item 1. Put the source code (bufsim3.cc) in SOURCES
 
@@ -2094,7 +2221,7 @@
 
 With SynSim:
 
-=over
+=over 4
 
 =item 1. Create a template file
 
@@ -2103,7 +2230,7 @@
 
 =item 2. Create a data file
 
-The .raw file is a binary file, so it should not be touched. SynSim creates output files with extension .out, and combines these with the headers etc. (cf. L<OUTPUT FILES>). By keeping the extension .raw, the simulator output files will not be touched. 
+The .raw file is a binary file, so it should not be touched. SynSim creates output files with extension .out, and combines these with the headers etc. (cf. L</"OUTPUT FILES">). By keeping the extension .raw, the simulator output files will not be touched. 
 
 In the datafile:
 
@@ -2117,10 +2244,155 @@
 
 =item 4. Postprocessing
 
-To access the binary files, you'll have to write your own postprocessing routines. Most likely they will rely on an external tool to process the binary data. The files will be found in the run directory, and have names as described in L<OUTPUT FILES>, with the extra extension .raw.
+To access the binary files, you will have to write your own postprocessing routines. Most likely they will rely on an external tool to process the binary data. The files will be found in the run directory, and have names as described in L</"OUTPUT FILES">, with the extra extension .raw.
 
 =back
 
+=head1 WRAPPERS
+
+If the simulator command line does not follow the format required by SynSim, a simple shell or perl wrapper is enough to make SynSim understand it.
+The wrapper script must be stored under F<SOURCES/>; it should be written such that all relative paths are correct when it is executed under F<SOURCES/>. That is because SynSim runs in a subdirectory fo the project directory. This means that, if the command line contains relative paths to a subdirectory, these paths must be prepended with '../'.
+
+=head2 1. No is wrapper required if the simulator takes input from a file with an arbitrary name and sends output in any way to a file with an arbitrary name: 
+
+        $ simulator INPUTFILE OUTPUTFILE
+        $ simulator --o OUTPUTFILE INPUTFILE 
+        $ simulator -i INPUTFILE > OUTPUTFILE
+        $ simulator < INPUTFILE > OUTPUTFILE
+
+=head2 2. Simulators with fixed input file name:
+
+Example:
+
+        $ simulator sim.conf > sim.out
+
+Wrapper:
+
+        $ simulator_wrapper.sh INPUTFILE > OUTPUTFILE 
+
+The file C<simulator_wrapper.sh> contains 2 lines:
+ 
+        mv $1 sim.conf
+        simulator sim.conf
+
+=head2 3. Simulator with a fixed output file name:
+
+Example:
+
+        $ simulator INPUTFILE
+
+The outputfile is called C<output.txt>.
+
+Wrapper: 
+
+        $ simulator_wrapper.sh INPUTFILE OUTPUTFILE 
+
+The file C<simulator_wrapper.sh> contains 2 lines:
+ 
+        simulator $1
+        mv output.txt $2
+
+=head2 4. Simulator takes input file from a subdirectory
+
+Example:
+
+        $ simulator ../Config/INPUTFILE > OUTPUTFILE
+
+The F<Config> directory is in this case at the same level of project directory.
+
+Wrapper: 
+        
+        $ simulator_wrapper.sh INPUTFILE > OUTPUTFILE 
+
+The file C<simulator_wrapper.sh> contains 2 lines. Note the '../' prepended to the paths:
+ 
+        cp $1 ../../Config
+        simulator ../../Config/INPUTFILE
+
+=head2 5. Simulator produces output in a subdirectory
+
+Example:
+
+        $ simulator INPUTFILE OUTPUTFILE 
+
+The C<OUTPUTFILE> is generated in the F<Results> subdirectory.
+
+Wrapper: 
+
+        $ simulator_wrapper.sh INPUTFILE OUTPUTFILE 
+
+The file C<simulator_wrapper.sh> contains 2 lines. Note the '../' prepended to the path:
+ 
+        simulator $1 $2
+        cp ../Results/$2 .
+
+=head2 6. Simulator with command-line input and fixed output file
+
+        $ simulator -a50 -b100 -c0.7
+
+Output is saved in out.txt.
+
+In this case, there is no actual wrapper script. We will create a simple shell script simulator.templ in TEMPLATES/. This script will act as the input file.
+
+Wrapper: 
+
+        $ bash INPUTFILE OUTPUTFILE 
+
+We need the explicit call to bash because the INPUTFILE does not have the -x flag set.
+
+The file simulator.templ in TEMPLATES/ contains 2 lines:
+        
+        simulator -a_VAR1 -b_VAR2 -c_VAR3
+        cp out.txt $1
+
+SynSim will create simulator.sh from this template file, and then will call bash to execute this shell script.
+
+=head2 7. Simulator requires multiple input files
+
+Example:
+
+        $ simulator config.in topo.in > out.res
+
+Wrapper: 
+
+        $ perl INPUTFILE OUTPUTFILE 
+
+Again, there is no actual wrapper script. The C<INPUTFILE> template is in this case a perl script which contains itself templates for both input files. The script will create both input files, then run the simulator.
+
+A possible implementation of simulator.templ:
+
+        #!/usr/bin/perl
+        #Template for simulator with multiple input files
+        my $config_templ=<<"ENDCONF";
+        /* This is the config.in template */
+        int var1 = _VAR1;
+
+        ...
+
+        ENDCONF
+
+        my $topo_templ=<<"ENDTOPO";
+        ;;This is the topo.in template
+        var2 = _VAR2
+
+        ...
+
+        ENDTOPO
+
+        open CONF,">config.in";
+        print CONF $config_templ;
+        close CONF;
+
+        open TOPO, ">topo.in";
+        print TOPO $topo_templ;
+        close TOPO;
+
+        system("simulator config.in topo.in > $ARGV[0]");
+ 
+        #END of simulator.templ
+
+SynSim will create C<simulator.pl> and then will call C<perl> to run the script
+
 =head1 TO DO
 
 This module is still Alpha, a lot of work remains to be done to make it more user-friendly. The main tasks is to add a GUI. A prototype can be found on my web site, it is already useful but too early to include here. The next version will also make it easier to create your own postprocessing routines.
Only in Simulation-Automate-1.0.0/eg: histogram.data
Only in Simulation-Automate-1.0.0/eg: PLUGINS
Only in Simulation-Automate-1.0.0/eg: qsweep.data
Only in Simulation-Automate-1.0.0/eg: quadratic_cond.data
Only in Simulation-Automate-1.0.0/eg: quadratic.data
Only in Simulation-Automate-1.0.0/eg/SOURCES: quadratic.py
Only in Simulation-Automate-1.0.0/eg/SOURCES: quadratic_sweep.py
diff -r -b -B --ignore-all-space -u Simulation-Automate-0.9.7/eg/synsim.data Simulation-Automate-1.0.0/eg/synsim.data
--- Simulation-Automate-0.9.7/eg/synsim.data	2003-09-04 10:45:19.000000000 +0000
+++ Simulation-Automate-1.0.0/eg/synsim.data	2003-12-09 13:19:58.000000000 +0000
@@ -1,2 +1,3 @@
-TITLE: SynSim test bufsim3
+TITLE: SynSim installation test
 SIMTYPE : test
+COMMAND: perl INPUTFILE OUTPUTFILE
Only in Simulation-Automate-1.0.0/eg/TEMPLATES: quadratic.gnuplot
Only in Simulation-Automate-1.0.0/eg/TEMPLATES: quadratic.gnuplot~
Only in Simulation-Automate-1.0.0/eg/TEMPLATES: quadratic_sweep.templ
Only in Simulation-Automate-1.0.0/eg/TEMPLATES: quadratic_sweep.templ~
Only in Simulation-Automate-1.0.0/eg/TEMPLATES: quadratic.templ
Only in Simulation-Automate-1.0.0/eg/TEMPLATES: test.templ
diff -r -b -B --ignore-all-space -u Simulation-Automate-0.9.7/eg/test.data Simulation-Automate-1.0.0/eg/test.data
--- Simulation-Automate-0.9.7/eg/test.data	2003-01-09 14:35:13.000000000 +0000
+++ Simulation-Automate-1.0.0/eg/test.data	2004-01-05 11:11:37.000000000 +0000
@@ -1,2 +1,7 @@
-TITLE: SynSim test bufsim3
-SIMTYPE : test
+TITLE: Test
+SIMULATION: simop
+COMMAND: ./simopwrapper.sh ../NEW_TEST inputfile outputfile
+OUTPUT_FILTER_PATTERN: delay
+ANALYSIS: XYPlot
+DATACOL:3
+_BERNOULLI= 0.8,0.9,0.95
Only in Simulation-Automate-1.0.0: local_install.pl
